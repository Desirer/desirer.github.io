<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Redis 应用篇 - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="从应用角度介绍Redis常见应用面试题。"><meta property="og:type" content="blog"><meta property="og:title" content="Redis 应用篇"><meta property="og:url" content="https://xyz.desirer233.fun/2024/02/19/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Redis%E5%BA%94%E7%94%A8%E7%AF%87/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="从应用角度介绍Redis常见应用面试题。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://markdown.desirer233.fun/202401171406283.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/430c7af86f2f4f3092720bea140bc818.png"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-5f158af9928ab084133362fb04a765ad_1440w.webp"><meta property="og:image" content="https://img-blog.csdnimg.cn/98910536004e41a9bd21d729fe1af748.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ed299ba20178d708459f32cf13af7873.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/eeb285cbb1aac10a225296e7493cc301.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/780cae1243e5c865f7b49f27e5b6136e.png"><meta property="article:published_time" content="2024-02-19T07:00:00.000Z"><meta property="article:modified_time" content="2024-06-05T07:38:30.995Z"><meta property="article:author" content="Desirer"><meta property="article:tag" content="Redis"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://markdown.desirer233.fun/202401171406283.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2024/02/19/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Redis%E5%BA%94%E7%94%A8%E7%AF%87/"},"headline":"Redis 应用篇","image":["http://markdown.desirer233.fun/202401171406283.png","https://img-blog.csdnimg.cn/430c7af86f2f4f3092720bea140bc818.png","https://pic2.zhimg.com/80/v2-5f158af9928ab084133362fb04a765ad_1440w.webp","https://img-blog.csdnimg.cn/98910536004e41a9bd21d729fe1af748.png","https://img-blog.csdnimg.cn/img_convert/ed299ba20178d708459f32cf13af7873.png","https://img-blog.csdnimg.cn/img_convert/eeb285cbb1aac10a225296e7493cc301.png","https://img-blog.csdnimg.cn/img_convert/780cae1243e5c865f7b49f27e5b6136e.png"],"datePublished":"2024-02-19T07:00:00.000Z","dateModified":"2024-06-05T07:38:30.995Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"从应用角度介绍Redis常见应用面试题。"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2024/02/19/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Redis%E5%BA%94%E7%94%A8%E7%AF%87/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-19T07:00:00.000Z" title="2024/2/19 15:00:00">2024-02-19</time>发表</span><span class="level-item"><time dateTime="2024-06-05T07:38:30.995Z" title="2024/6/5 15:38:30">2024-06-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span><span class="level-item">38 分钟读完 (大约5768个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Redis 应用篇</h1><div class="content"><p>从应用角度介绍Redis常见应用面试题。</p>
<span id="more"></span>

<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>（1）概念</p>
<p>客户端请求的数据在缓存和数据库中都不存在。如果持续发起这个请求，那么缓存会失效，好像不存在。</p>
<p>（2）解决方法</p>
<ul>
<li>缓存空对象</li>
<li>布隆过滤器</li>
</ul>
<p>缓存空对象是在数据库未命中时，缓存一个null并设置一个短有效时间。</p>
<p>布隆过滤器则是在缓存前的一道关卡，查询数据是否存在，具体实现未知。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>（1）概念</p>
<p>缓存雪崩就是同一时间大量key失效或者直接Redis宕机。那么这时候针对不同的key的大量请求都会要求重建缓存，数据库压力大。</p>
<p>（2）解决方法</p>
<ul>
<li>为不同的key设置不同的过期时间（随机TTL）</li>
<li>Redis集群</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>（1）概念</p>
<p>缓存击穿也称之为热点key问题，一旦热点key失效，那么大量的请求都会打到数据库（在缓存重建时间内）。</p>
<p>（2）解决方法</p>
<ul>
<li>互斥锁：为缓存重建的过程加锁，只有一个线程能拿到锁进行缓存重建，<strong>没拿到锁的线程休眠一段时间，再次查缓存，直到缓存重建完成</strong>。</li>
<li>逻辑过期：不设置热点key的过期时间，由代码判断key的value中的expireTime字段是否过期。如果过期，由互斥锁保证开启一个新线程重建缓存，未获得锁的其他线程直接返回旧数据。</li>
</ul>
<p><img src="http://markdown.desirer233.fun/202401171406283.png"></p>
<h2 id="缓存与数据库的一致性"><a href="#缓存与数据库的一致性" class="headerlink" title="缓存与数据库的一致性"></a>缓存与数据库的一致性</h2><p>读操作：缓存命中直接返回；缓存未命中，则查询数据库，然后更新缓存并设置有效时间。</p>
<p>写操作：写数据库，然后选择主动更新缓存抑或删除缓存。</p>
<h3 id="四种同步策略（数据库更新时主动更新缓存）"><a href="#四种同步策略（数据库更新时主动更新缓存）" class="headerlink" title="四种同步策略（数据库更新时主动更新缓存）"></a>四种同步策略（数据库更新时主动更新缓存）</h3><ul>
<li>先更新缓存再更新数据库：第二步失败缓存库是脏数据</li>
<li><strong>先更新数据库再更新缓存：</strong>第二步失败缓存库是旧数据</li>
<li>先删除缓存再更新数据库：第二步失败缓存库是空数据</li>
<li><strong>先更新数据库、再删除缓存（推荐）：</strong>第二步失败缓存库是旧数据</li>
</ul>
<h3 id="更新缓存or删除缓存"><a href="#更新缓存or删除缓存" class="headerlink" title="更新缓存or删除缓存"></a>更新缓存or删除缓存</h3><p>更新缓存的优点是每次数据变化都能及时更新缓存，但缺点是操作消耗大，频繁更新缓存会影响服务器性能。</p>
<p>删除缓存优点是操作简单，惰性重建，将重建代价移动到下一次访问。</p>
<h3 id="更新数据库与删除缓存的时序"><a href="#更新数据库与删除缓存的时序" class="headerlink" title="更新数据库与删除缓存的时序"></a>更新数据库与删除缓存的时序</h3><img src="https://img-blog.csdnimg.cn/430c7af86f2f4f3092720bea140bc818.png" style="zoom:80%;" />

<p>先删缓存再更新数据库：线程1删除缓存后，线程2查询缓存不存在，然后重新写入缓存，此时缓存为旧数据。线程1再更新数据库为新数据。那么就出现了缓存旧数据、数据库新数据的不一致性。</p>
<p>先更新数据库在删除缓存：恰好缓存数据失效，线程1查缓存失效，查数据库旧数据；线程2更新数据库；线程1再更新缓存。这种不一致性出现概率低。</p>
<h3 id="最优同步策略：先更新数据库、再删除缓存"><a href="#最优同步策略：先更新数据库、再删除缓存" class="headerlink" title="最优同步策略：先更新数据库、再删除缓存"></a>最优同步策略：先更新数据库、再删除缓存</h3><p>所以我们得到结论：先更新数据库、再删除缓存是影响更小的方案。如果第二步出现失败的情况，则可以采用重试机制解决问题。</p>
<p>同步删除方案： 先更新数据库、再删除缓存。适用于不强制要求数据一致性的情景</p>
<p>流程：先更新数据库、再删除缓存。</p>
<p>问题：</p>
<ul>
<li>并发时脏数据：在查询数据库到写缓存期间其他线程执行了一次更新删除，导致缓存的数据是旧数据</li>
<li>缓存删除失败：删除失败导致缓存库还是旧数据</li>
</ul>
<h3 id="同步删除-可靠消息方案"><a href="#同步删除-可靠消息方案" class="headerlink" title="同步删除+可靠消息方案"></a>同步删除+可靠消息方案</h3><p><strong>同步删除+可靠消息删除：</strong> 解决缓存删除失败问题，利用可靠消息多次重试删除缓存操作。</p>
<p><strong>流程：</strong>先更新数据库、再删除缓存，如果删除失败就发可靠MQ不断重试删除缓存，直到删除成功或重试5次。</p>
<p><strong>问题：</strong>消息队列中消息消费有时延，数据不一致时间较长（适用于不强制要求数据一致性的情景）；MQ多次重试失败，导致长期脏数据</p>
<h3 id="延迟双删：更高一致性"><a href="#延迟双删：更高一致性" class="headerlink" title="延迟双删：更高一致性"></a>延迟双删：更高一致性</h3><p><strong>流程：</strong>先删除缓存再更新数据库，然后在从数据库库更新后再删一次缓存。</p>
<p>为什么要延时呢？为了分布式系统下主从同步。</p>
<p>数据工作的大致流程：</p>
<ol>
<li>主节点删除 redis 库数据；</li>
<li>主节点修改 mysql 库数据；</li>
<li>当前业务处理 等待一段时间，等 redis 和 mysql 主从节点数据同步；</li>
<li>从节点 redis 主库删除数据；</li>
<li>其它服务节点读取 redis 从库数据，发现没有数据，从 mysql 从库读取数据，并写入 redis 主库。</li>
</ol>
<p><strong>问题：</strong>时间无法控制，不能保证在数据库从库更新后删除缓存。如果在从库更新前删除，用户再在更新前查从库又把脏数据写在缓存里了。</p>
<h3 id="异步监听数据库-可靠消息删除"><a href="#异步监听数据库-可靠消息删除" class="headerlink" title="异步监听数据库+可靠消息删除"></a>异步监听数据库+可靠消息删除</h3><p>流程：</p>
<ol>
<li>更新数据库后不做操作；</li>
<li>Canal等组件监听binlog发现有更新时就发可靠MQ删除缓存；</li>
<li>如果删除缓存失败，就基于手动ack、retry等机制，让消息在有限次数之内不断重试。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>异步删除，性能更高；</li>
<li>可靠消息重试机制，多次删除保证删除成功。</li>
</ul>
<p><strong>问题：</strong>要求canal等binlog抓取组件高可用，如果canal故障，会导致长期脏数据。</p>
<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>常见限流算法：</p>
<ul>
<li>计数器算法</li>
<li>滑动窗口算法</li>
<li>漏桶算法</li>
<li>令牌桶算法</li>
</ul>
<h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>比如说我要维持1秒内最多200个请求访问，那么我就设置一个计数器表示1秒内请求访问的数量，每隔一秒固定清空计数器。可以自定义窗口时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">fixedWindowsTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//获取系统当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (currentTime - lastRequestTime &gt; windowUnit) &#123;  <span class="comment">//检查是否在时间窗口内</span></span><br><span class="line">        counter = <span class="number">0</span>;  <span class="comment">// 计数器清0</span></span><br><span class="line">        lastRequestTime = currentTime;  <span class="comment">//开启新的时间窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">if</span> (counter &gt;= threshold) <span class="keyword">return</span> flase;</span><br><span class="line">    counter++;  <span class="comment">//计数器加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>坏处：临界请求问题。比如0.9s有200个请求，1.1s有200个请求，那么实际在0.5到1.5s之间处理了400个请求。</p>
<h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p>滑动窗口的思想是将一个窗口细分为若干个小窗口，每个小窗口独立负责一个时间段的请求限流，随着时间的前进，最旧的窗口丢弃，新的空窗口生成。</p>
<p>通过细化窗口的方式，能够将临界请求也一起细化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">SUB_CYCLE</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 单位时间划分的小周期（单位时间是1分钟，10s一个小格子窗口，一共6个格子）</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">thresholdPerMin</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//  每分钟限流请求数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Integer&gt; counters = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 计数器, key为当前窗口的开始时间值秒，value为当前窗口的计数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">slidingWindowsTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">//获取当前时间在哪个小周期窗口</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">currentWindowTime</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) / SUB_CYCLE * SUB_CYCLE; </span><br><span class="line">    <span class="comment">//当前窗口总请求数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentWindowNum</span> <span class="operator">=</span> countCurrentWindow(currentWindowTime); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentWindowNum &gt;= thresholdPerMin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    counters.get(currentWindowTime)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 统计当前窗口的请求数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countCurrentWindow</span><span class="params">(<span class="type">long</span> currentWindowTime)</span> &#123;</span><br><span class="line">    <span class="comment">//计算窗口开始位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> currentWindowTime - SUB_CYCLE* (<span class="number">60</span>/SUB_CYCLE-<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历存储的计数器</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;Long, Integer&gt;&gt; iterator = counters.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;Long, Integer&gt; entry = iterator.next();</span><br><span class="line">        <span class="comment">// 删除无效过期的子窗口计数器</span></span><br><span class="line">        <span class="keyword">if</span> (entry.getKey() &lt; startTime) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count =count + entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><img src="https://pic2.zhimg.com/80/v2-5f158af9928ab084133362fb04a765ad_1440w.webp" style="zoom:80%;" />

<p>漏桶算法采取一个容器存储到来的请求，以生产者消费者的思想处理请求。客户端是生产者，实际流量的产生者；服务端是消费者，负责消费容器中的请求。容器的大小是固定的，超出容器大小的请求将会被丢弃。</p>
<p>这样就能保证以不超过固定消费速率的方式处理请求。缺点是：消费速率固定，无法调整。如果大量请求到来，我们希望提高系统的处理效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> rate; <span class="comment">// 每秒处理数（出水率）</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> currentWater; <span class="comment">//当前剩余水量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> refreshTime; <span class="comment">// 最后刷新时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">// 桶容量</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">leakybucketLimitTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//获取系统当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">outWater</span> <span class="operator">=</span> (currentTime - refreshTime) / <span class="number">1000</span> * rate; <span class="comment">//流出的水量 =(当前时间-上次刷新时间)* 出水率</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">currentWater</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, currentWater - outWater); <span class="comment">// 当前水量 = 之前的桶内水量-流出的水量</span></span><br><span class="line">    refreshTime = currentTime; <span class="comment">// 刷新时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前剩余水量还是小于桶的容量，则请求放行</span></span><br><span class="line">    <span class="keyword">if</span> (currentWater &lt; capacity) &#123;</span><br><span class="line">        currentWater++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前剩余水量大于等于桶的容量，限流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法改良了漏桶算法，使得消费的速率能够调整。具体实现为：漏桶不再存储请求，而是存储令牌。每个请求要先获得令牌才能被处理。</p>
<p><strong>此时桶的生产者和消费者倒置：由服务端以可调整的速率生成令牌，由客户端请求消费令牌。如果请求拿不到令牌，就直接放弃处理。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> putTokenRate; <span class="comment">//每秒处理数（放入令牌数量）</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> refreshTime; <span class="comment">//最后刷新时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> capacity; <span class="comment">//令牌桶容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">currentToken</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 令牌桶容量</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tokenBucketTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//获取系统当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">generateToken</span> <span class="operator">=</span> (currentTime - refreshTime) / <span class="number">1000</span> * putTokenRate; <span class="comment">//生成的令牌 =(当前时间-上次刷新时间)* 放入令牌的速率</span></span><br><span class="line">    currentToken = Math.min(capacity, generateToken + currentToken); <span class="comment">// 当前令牌数量 = 之前的桶内令牌数量+放入的令牌数量</span></span><br><span class="line">    refreshTime = currentTime; <span class="comment">// 刷新时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶里面还有令牌，请求正常处理</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        currentToken--; <span class="comment">//令牌数量-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis实现限流"><a href="#Redis实现限流" class="headerlink" title="Redis实现限流"></a>Redis实现限流</h1><h2 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h2><p>主要是利用Redis的ZSet数据结构来实现，每个请求的value都要保持互不相同，score为当前时间戳。利用ZSet的range，查询当前时间窗口内的请求数量，进而达到限流作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">limitFlow</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">        System.out.println(currentTime);</span><br><span class="line">        <span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">&quot;limit&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForZSet().rangeByScore(<span class="string">&quot;limit&quot;</span>, currentTime -  intervalTime, currentTime).size();        <span class="comment">// intervalTime是限流的时间 </span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="literal">null</span> &amp;&amp; count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Response.ok(<span class="string">&quot;每分钟最多只能访问5次&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;limit&quot;</span>,UUID.randomUUID().toString(),currentTime);</span><br><span class="line">        <span class="keyword">return</span> Response.ok(<span class="string">&quot;访问成功&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码可以做到滑动窗口的效果，并且能保证每N秒内至多M个请求，缺点就是zset的数据结构会越来越大。</p>
<h2 id="令牌桶方法"><a href="#令牌桶方法" class="headerlink" title="令牌桶方法"></a>令牌桶方法</h2><p>Redis实现令牌桶，实际就是让Redis充当桶的角色。类似消息队列的意味，利用Redis的list实现令牌的队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得令牌</span></span><br><span class="line">		<span class="keyword">public</span> Response <span class="title function_">limitFlow2</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.opsForList().leftPop(<span class="string">&quot;limit_list&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Response.ok(<span class="string">&quot;当前令牌桶中无令牌&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.ok(articleDescription2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 10S的速率往令牌桶中添加UUID，只为保证唯一性</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 10_000,initialDelay = 0)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntervalTimeTask</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.opsForList().rightPush(<span class="string">&quot;limit_list&quot;</span>,UUID.randomUUID().toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>依靠Java的定时任务，定时往List中rightPush令牌，当然令牌也需要唯一性。</p>
<h1 id="全局ID生成"><a href="#全局ID生成" class="headerlink" title="全局ID生成"></a>全局ID生成</h1><p>全局id生成器，是在分布式系统下用来生成全局唯一ID的工具，</p>
<img src="https://img-blog.csdnimg.cn/98910536004e41a9bd21d729fe1af748.png" style="zoom:80%;" />

<p>设计思想：时间戳以秒为单位，留下1秒的时间让业务并发。这1秒的时间最多2的32次方个id。我不同的业务使用不同的key自增，业务再怎么大，一秒2的32次方个id也是够用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">//开始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1674086400L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列号位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> time.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2.生成序列号,redis自增长,redis单个key自增长有上限，2的64次方</span></span><br><span class="line">        <span class="comment">//2.1获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="comment">//3.拼接并返回,不能使用字符串方式拼接</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<span class="comment">//先向左移32位，那么低32位全为0，跟序列号进行或操作</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成开始时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">second</span> <span class="operator">=</span> time.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        System.out.println(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="简单的分布式锁"><a href="#简单的分布式锁" class="headerlink" title="简单的分布式锁"></a>简单的分布式锁</h2><p>利用setnx实现简单的分布式锁，锁名称由业务决定，并完成锁的初始化（初始化需要传入锁名称）tryLock返回加锁是否成功的判断。锁需要设置超时过期时间，避免业务阻塞造成锁无法释放。</p>
<p>获取锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock thread1 NX EX 10</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String lock_name; <span class="comment">//业务名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        lock_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、确定key和value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + lock_name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Thread.currentThread().getId() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 2、执行setnx</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">succ</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, value, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(succ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + lock_name;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁失败，由业务自己决定是否重试。</p>
<h2 id="改进分布式锁"><a href="#改进分布式锁" class="headerlink" title="改进分布式锁"></a>改进分布式锁</h2><h3 id="锁二次删除问题"><a href="#锁二次删除问题" class="headerlink" title="锁二次删除问题"></a>锁二次删除问题</h3><p>考虑这么一个场景：线程获得锁后阻塞，超过过期时间，锁删除。第二个线程获得锁，但一个线程恢复后删除了第二个线程持有的锁。最后导致第三个线程又获得了锁。</p>
<p>改进方法：利用锁的value来判断当前持有锁的线程。每个机器上线程都要有一个全局ID。释放锁时需要判断锁是否是自己的。</p>
<p>加锁：指定锁的value 为线程的全局ID。</p>
<p>释放锁：释放锁一共有三个步骤，先获取锁的value，然后判断value是否为当前线程ID，如果是才能删除锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String lock_name; <span class="comment">//业务名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        lock_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VALUE_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>)+<span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、确定key和value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KEY_PREFIX + lock_name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 2、执行setnx</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">succ</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, value, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(succ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KEY_PREFIX + lock_name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">lock_value</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.equals(value, lock_value)) <span class="comment">// 线程只能释放自己持有的锁！</span></span><br><span class="line">            stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁原子性问题"><a href="#释放锁原子性问题" class="headerlink" title="释放锁原子性问题"></a>释放锁原子性问题</h3><p>释放锁的过程可能被阻塞（JVM的垃圾回收机制导致的短暂阻塞），因此要采用LUA脚本保证原子性。</p>
<p>（1）编写lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取key和value</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> value = ARGV[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断get（key）和value是否一致</span></span><br><span class="line"><span class="keyword">local</span> lock_value = redis.call(<span class="string">&#x27;GET&#x27;</span>, key)</span><br><span class="line"><span class="keyword">if</span> lock_value == value <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>（2）加载lua脚本并执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String lock_name; <span class="comment">//业务名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        lock_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载Lua脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lock.lua&quot;</span>));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VALUE_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>)+<span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、确定key和value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KEY_PREFIX + lock_name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 2、执行setnx</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">succ</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, value, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(succ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KEY_PREFIX + lock_name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 调用LUA脚本释放锁,保证原子性</span></span><br><span class="line">        stringRedisTemplate.execute(LOCK_SCRIPT, Collections.singletonList(key), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，一个简单的不可重入的无重试机制的分布式锁就完成了。</p>
<p>后续改进：</p>
<ul>
<li>可重入性（需要记录线程获锁的次数，当次数为0时释放锁）</li>
<li>重试机制</li>
<li>续约机制</li>
<li>主从一致性问题</li>
</ul>
<h2 id="可重入分布式锁实现"><a href="#可重入分布式锁实现" class="headerlink" title="可重入分布式锁实现"></a>可重入分布式锁实现</h2><p>可重入锁需要维护引用计数，简单的string类型无法满足需求，需要换用hash类型。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ed299ba20178d708459f32cf13af7873.png"></p>
<p>加锁：两次判断，第一次判断锁是否存在；如果不存在创建锁；如果存在，增加引用计数。</p>
<p>释放锁：两次判断，引用计数减1；如果引用计数为0，删除锁。</p>
<p>由于加锁和释放锁都是多步操作，因此均采用LUA脚本。</p>
<p>（1）获取锁的lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> threadId  = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1、查询key是否存在</span></span><br><span class="line"><span class="comment">-- 1.1 不存在直接获取锁，并设置过期时间</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、如果key存在，再比较field是否是当前线程(锁是否是自己的）</span></span><br><span class="line"><span class="comment">-- 2.1 如果是当前线程，引用计数加1并重设有效期返回ture</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- return 1 获取锁成功，0失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>（2）释放锁的lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> threadId  = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、判断要释放的锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 2、锁存在，引用计数减1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进一步判断是否需要释放锁</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 重入次数大于0，说明不能释放锁，且刷新锁的有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 重入次数等于0，说明可以释放锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>（3）可重入锁类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.lang.UUID;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String lock_name; <span class="comment">//业务名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeOutSec;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        lock_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载Lua脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;get_lock.lua&quot;</span>));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;release_lock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VALUE_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>)+<span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.timeOutSec = timeoutSec;</span><br><span class="line">        <span class="comment">// 1、确定key和value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KEY_PREFIX + lock_name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 2、执行setnx</span></span><br><span class="line"><span class="comment">//        Boolean succ = stringRedisTemplate.opsForValue().setIfAbsent(key, value, timeoutSec, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(LOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key), value, Long.toString(timeoutSec));</span><br><span class="line"><span class="comment">//        System.out.println(result);</span></span><br><span class="line">        <span class="keyword">return</span> result!=<span class="literal">null</span> &amp;&amp; result.equals(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KEY_PREFIX + lock_name;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line"><span class="comment">//        String lock_value = stringRedisTemplate.opsForValue().get(key);</span></span><br><span class="line"><span class="comment">//        if(StrUtil.equals(value, lock_value)) // 线程只能释放自己持有的锁！</span></span><br><span class="line"><span class="comment">//            stringRedisTemplate.delete(key);</span></span><br><span class="line">        <span class="comment">// 调用LUA脚本释放锁,保证原子性</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key), value, Long.toString(<span class="built_in">this</span>.timeOutSec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="滚动推送"><a href="#滚动推送" class="headerlink" title="滚动推送"></a>滚动推送</h1><h2 id="TimeLine推送模型"><a href="#TimeLine推送模型" class="headerlink" title="TimeLine推送模型"></a>TimeLine推送模型</h2><p>最典型的就是朋友圈，按照内容产生的时间顺序推送给关注用户。</p>
<p>实现模式：推模式、拉模式、推拉结合</p>
<p>推模式就是当前用户发布一条内容后，马上将这条内容推送到每个粉丝的收件箱。适合粉丝数少的一般人。</p>
<p>拉模式则相反，用户发布的内容先暂存到发件箱，当粉丝用户查看内容时，再从发件箱拉取内容到收件箱消费。适合粉丝众多的大V。</p>
<p>推拉模式结合适合用于大V的活跃粉丝和不活跃粉丝。活跃粉丝用推模式，不活跃粉丝用拉模式。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/eeb285cbb1aac10a225296e7493cc301.png" style="zoom:80%;" />

<h2 id="Redis实现推模式"><a href="#Redis实现推模式" class="headerlink" title="Redis实现推模式"></a>Redis实现推模式</h2><p>推模式包括推送加收取。推送：将内容id推送的粉丝的收件箱；拉取：从个人收件箱拉取推文id。</p>
<p>可以利用set维护用户关注表，查找出所有粉丝ID。收件箱利用ZSet，每个推文加上时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 保存探店博文</span></span><br><span class="line">    save(blog);</span><br><span class="line">    <span class="comment">// 1、查找当前用户的粉丝</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 2、将blog的id推送到粉丝的收件箱</span></span><br><span class="line">    follows.forEach(</span><br><span class="line">        follow -&gt; &#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().add(FEED_KEY+follow.getUserId(), blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滚动分页查询：回想起朋友圈，可以一直往下滚动，浏览旧时间的朋友圈内容。如果想消费最新内容，往上滑刷新，就得到了最新内容。</p>
<p>实现：对推文进行时间戳进行降序排序，记录每次读的最后一条推文的时间戳位置。下次读从上次记录到的位置开始。<strong>如果是刷新的情况，则从头开始读（新的推文一定在头部，因为时间戳较大）。</strong></p>
<img src="https://img-blog.csdnimg.cn/img_convert/780cae1243e5c865f7b49f27e5b6136e.png" style="zoom:80%;" />

<p>这在Redis的ZSet对应的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGEBYSCORE key Max Min LIMIT offset count</span><br></pre></td></tr></table></figure>

<p>ZSet+Reverse+RangeByScore，按照分数降序排序。Max则是要读取的最大分数，Min是要读取的最低分数。offset就是偏移量，count就是读取的数据条数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long lastId, Integer offset)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//1、从Redis的收件箱中查询博客id</span></span><br><span class="line">    <span class="comment">// ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(FEED_KEY + userId, <span class="number">0</span>, lastId, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(typedTuples==<span class="literal">null</span>||typedTuples.isEmpty())&#123;</span><br><span class="line">         <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、解析获得的数据</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ofset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> typedTuple.getValue();</span><br><span class="line">        ids.add(Long.valueOf(idStr));</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            ofset+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            ofset=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、从数据库中查询博客的具体信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStrs</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStrs + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            .list();</span><br><span class="line">    blogs.forEach(blog-&gt;&#123;</span><br><span class="line">        queryUserByBlog(blog);</span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 4、封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    scrollResult.setList(blogs);</span><br><span class="line">    scrollResult.setOffset(ofset);</span><br><span class="line">    scrollResult.setMinTime(minTime);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中第一次查询时，lastId传当前时间戳；此后第二次查询，lastId为上次查询的最小时间戳，</p>
<p>偏移量是为了记住同一时间发布的推文数量，假如上次查询的最小时间戳一共有5条推文，那么下次查询必须从第6次推文读起。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Redis 应用篇</p><p><a href="https://xyz.desirer233.fun/2024/02/19/后端开发/Redis应用篇/">https://xyz.desirer233.fun/2024/02/19/后端开发/Redis应用篇/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-02-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-06-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Redis/">Redis</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/02/27/MIT6.824/%E7%AC%94%E8%AE%B08Aurora/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MIT6824笔记八 Aurora</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/csapp%E7%AC%AC8%E7%AB%A0%E4%BF%A1%E5%8F%B7/"><span class="level-item">CSAPP第八章信号部分</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#缓存"><span class="level-left"><span class="level-item">1</span><span class="level-item">缓存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#缓存穿透"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">缓存穿透</span></span></a></li><li><a class="level is-mobile" href="#缓存雪崩"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">缓存雪崩</span></span></a></li><li><a class="level is-mobile" href="#缓存击穿"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">缓存击穿</span></span></a></li><li><a class="level is-mobile" href="#缓存与数据库的一致性"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">缓存与数据库的一致性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#四种同步策略（数据库更新时主动更新缓存）"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">四种同步策略（数据库更新时主动更新缓存）</span></span></a></li><li><a class="level is-mobile" href="#更新缓存or删除缓存"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">更新缓存or删除缓存</span></span></a></li><li><a class="level is-mobile" href="#更新数据库与删除缓存的时序"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">更新数据库与删除缓存的时序</span></span></a></li><li><a class="level is-mobile" href="#最优同步策略：先更新数据库、再删除缓存"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">最优同步策略：先更新数据库、再删除缓存</span></span></a></li><li><a class="level is-mobile" href="#同步删除-可靠消息方案"><span class="level-left"><span class="level-item">1.4.5</span><span class="level-item">同步删除+可靠消息方案</span></span></a></li><li><a class="level is-mobile" href="#延迟双删：更高一致性"><span class="level-left"><span class="level-item">1.4.6</span><span class="level-item">延迟双删：更高一致性</span></span></a></li><li><a class="level is-mobile" href="#异步监听数据库-可靠消息删除"><span class="level-left"><span class="level-item">1.4.7</span><span class="level-item">异步监听数据库+可靠消息删除</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#限流"><span class="level-left"><span class="level-item">2</span><span class="level-item">限流</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#计数器算法"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">计数器算法</span></span></a></li><li><a class="level is-mobile" href="#滑动窗口算法"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">滑动窗口算法</span></span></a></li><li><a class="level is-mobile" href="#漏桶算法"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">漏桶算法</span></span></a></li><li><a class="level is-mobile" href="#令牌桶算法"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">令牌桶算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Redis实现限流"><span class="level-left"><span class="level-item">3</span><span class="level-item">Redis实现限流</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#滑动窗口法"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">滑动窗口法</span></span></a></li><li><a class="level is-mobile" href="#令牌桶方法"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">令牌桶方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#全局ID生成"><span class="level-left"><span class="level-item">4</span><span class="level-item">全局ID生成</span></span></a></li><li><a class="level is-mobile" href="#分布式锁"><span class="level-left"><span class="level-item">5</span><span class="level-item">分布式锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简单的分布式锁"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">简单的分布式锁</span></span></a></li><li><a class="level is-mobile" href="#改进分布式锁"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">改进分布式锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#锁二次删除问题"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">锁二次删除问题</span></span></a></li><li><a class="level is-mobile" href="#释放锁原子性问题"><span class="level-left"><span class="level-item">5.2.2</span><span class="level-item">释放锁原子性问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#可重入分布式锁实现"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">可重入分布式锁实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#滚动推送"><span class="level-left"><span class="level-item">6</span><span class="level-item">滚动推送</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#TimeLine推送模型"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">TimeLine推送模型</span></span></a></li><li><a class="level is-mobile" href="#Redis实现推模式"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Redis实现推模式</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/PostgreSQL/"><span class="level-start"><span class="level-item">PostgreSQL</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/cmu15445/"><span class="level-start"><span class="level-item">cmu15445</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/openGauss/"><span class="level-start"><span class="level-item">openGauss</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/GDB/"><span class="level-start"><span class="level-item">GDB</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/IDE/"><span class="level-start"><span class="level-item">IDE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="level-start"><span class="level-item">命令行</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>