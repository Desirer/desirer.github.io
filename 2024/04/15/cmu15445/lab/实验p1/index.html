<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>实验P1 - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="实验一要求实现一个缓冲池实例，包括动态扩张的哈希表、基于LRU-K的替换器。 动态哈希表的难点在于理清数据结构，数据插入与扩容过程，不要求缩容。 LRU-K的实现比较坑，如果没有理解替换器与缓冲池整体的关系，也就很难理解各个函数的实现。 建议看教材：Database System Concepts 里面讲得比较清晰。"><meta property="og:type" content="blog"><meta property="og:title" content="实验P1"><meta property="og:url" content="https://xyz.desirer233.fun/2024/04/15/cmu15445/lab/%E5%AE%9E%E9%AA%8Cp1/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="实验一要求实现一个缓冲池实例，包括动态扩张的哈希表、基于LRU-K的替换器。 动态哈希表的难点在于理清数据结构，数据插入与扩容过程，不要求缩容。 LRU-K的实现比较坑，如果没有理解替换器与缓冲池整体的关系，也就很难理解各个函数的实现。 建议看教材：Database System Concepts 里面讲得比较清晰。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic2.zhimg.com/v2-0ff1430bad7f12a37c814e039a437fb7_1440w.jpg"><meta property="og:image" content="http://markdown.desirer233.fun/202404221419620.png"><meta property="og:image" content="http://markdown.desirer233.fun/202404221425571.png"><meta property="og:image" content="http://markdown.desirer233.fun/202404221453835.jpeg"><meta property="og:image" content="http://markdown.desirer233.fun/202404221514592.jpeg"><meta property="og:image" content="http://markdown.desirer233.fun/202404221514592.jpeg"><meta property="article:published_time" content="2024-04-15T07:00:00.000Z"><meta property="article:modified_time" content="2025-05-25T07:57:07.834Z"><meta property="article:author" content="Desirer"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://pic2.zhimg.com/v2-0ff1430bad7f12a37c814e039a437fb7_1440w.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2024/04/15/cmu15445/lab/%E5%AE%9E%E9%AA%8Cp1/"},"headline":"实验P1","image":["https://pic2.zhimg.com/v2-0ff1430bad7f12a37c814e039a437fb7_1440w.jpg","http://markdown.desirer233.fun/202404221419620.png","http://markdown.desirer233.fun/202404221425571.png"],"datePublished":"2024-04-15T07:00:00.000Z","dateModified":"2025-05-25T07:57:07.834Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"实验一要求实现一个缓冲池实例，包括动态扩张的哈希表、基于LRU-K的替换器。 动态哈希表的难点在于理清数据结构，数据插入与扩容过程，不要求缩容。 LRU-K的实现比较坑，如果没有理解替换器与缓冲池整体的关系，也就很难理解各个函数的实现。 建议看教材：Database System Concepts 里面讲得比较清晰。"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2024/04/15/cmu15445/lab/%E5%AE%9E%E9%AA%8Cp1/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-15T07:00:00.000Z" title="2024/4/15 15:00:00">2024-04-15</time>发表</span><span class="level-item"><time dateTime="2025-05-25T07:57:07.834Z" title="2025/5/25 15:57:07">2025-05-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/cmu15445/">cmu15445</a><span> / </span><a class="link-muted" href="/categories/cmu15445/lab/">lab</a></span><span class="level-item">23 分钟读完 (大约3504个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">实验P1</h1><div class="content"><p>实验一要求实现一个缓冲池实例，包括动态扩张的哈希表、基于LRU-K的替换器。</p>
<p>动态哈希表的难点在于理清数据结构，数据插入与扩容过程，不要求缩容。</p>
<p>LRU-K的实现比较坑，如果没有理解替换器与缓冲池整体的关系，也就很难理解各个函数的实现。</p>
<p>建议看教材：Database System Concepts 里面讲得比较清晰。</p>
<span id="more"></span>

<h1 id="Extendible-hash-table"><a href="#Extendible-hash-table" class="headerlink" title="Extendible hash table"></a>Extendible hash table</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Extendible Hashing</strong> is a dynamic hashing method wherein directories, and buckets are used to hash data. It is an aggressively flexible method in which the hash function also experiences dynamic changes. </p>
<p><strong>Frequently used terms in Extendible Hashing:</strong> </p>
<ul>
<li><strong>Directories:</strong> These containers store pointers to buckets. Each directory is given a unique id which may change each time when expansion takes place. The hash function returns this directory id which is used to navigate to the appropriate bucket. Number of Directories &#x3D; 2^Global Depth.</li>
<li><strong>Buckets:</strong> They store the hashed keys. Directories point to buckets. A bucket may contain more than one pointers to it if its local depth is less than the global depth.</li>
<li><strong>Global Depth:</strong> It is associated with the Directories. They denote the number of bits which are used by the hash function to categorize the keys. Global Depth &#x3D; Number of bits in directory id.</li>
<li><strong>Local Depth:</strong> It is the same as that of Global Depth except for the fact that Local Depth is associated with the buckets and not the directories. Local depth in accordance with the global depth is used to decide the action that to be performed in case an overflow occurs. Local Depth is always less than or equal to the Global Depth.</li>
<li><strong>Bucket Splitting:</strong> When the number of elements in a bucket exceeds a particular size, then the bucket is split into two parts.</li>
<li><strong>Directory Expansion:</strong> Directory Expansion Takes place when a bucket overflows. Directory Expansion is performed when the local depth of the overflowing bucket is equal to the global depth.</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-0ff1430bad7f12a37c814e039a437fb7_1440w.jpg"></p>
<p>Extendible Hash是动态扩容的哈希表，有两个重要概念：directory和bucket。bucket直译为桶，directory直译为目录。桶是一个固定数量的容器，目录就真的是目录（看作存储桶指针的线性表，表动态增长）。</p>
<p>（1）查找过程</p>
<img src="http://markdown.desirer233.fun/202404221419620.png" style="zoom:50%;" />

<p>首先，通过hash function找到Directory的Index，然后找到对应的Bucket，Bucket就是个链表，顺序查找。</p>
<p>（2）插入过程</p>
<p>extendible hash table的bucket是固定大小的，当Bucket满时只会创建新桶，而不是扩容桶大小。新桶会链接到目录（directory）上，当目录条目满时，触发目录的扩容。这就是extendible hash table的主要扩容逻辑。</p>
<p>当然，实现上有global depth和local depth来加速判断目录是否需要扩容。具体地，当前bucket有$2^{global-local}$个指针指向它，当 global&#x3D;&#x3D;local时，只有一个指针，这时候桶满扩容的同时需要目录扩容。</p>
<img src="http://markdown.desirer233.fun/202404221425571.png" style="zoom:50%;" />

<p>有两种扩容情况：</p>
<ul>
<li>local depth &lt; global depth</li>
<li>local depth &#x3D;&#x3D; global depth</li>
</ul>
<p>第一种情况只涉及bucket split，第二种情况涉及bucket split 和 directory expansion。</p>
<p>bucket split过程：增加local depth，然后创建两个新桶，根据新的local depth将原桶的数据分配（采取位运算）到新的两个桶中。最后调整directory的指针，即将指向原桶的指针分配（采取位运算）给新的两个桶。</p>
<p>directory expansion过程：将directory扩容至原先两倍，扩容采取复制的办法。这样指向每一个桶的指针就会变为原先的两倍。</p>
<p>（3）初始情况</p>
<p>global depth&#x3D;0， local depth &#x3D;0，directory大小为1，即只有一个桶。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li><p>实验要求的insert接口，对于相同的Key时，能够做到修改值而不是返回错误。这点如果没有确认，线上测试的InsertAndReplace测试项就会不通过。</p>
</li>
<li><p>即使桶分裂、目录扩张后，新的桶可能还是满的（数据的低N位为止都相同），需要递归插入。</p>
</li>
<li><p>递归时需要先释放锁，避免死锁（锁不可重入）。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> K &amp;key, <span class="type">const</span> V &amp;value) &#123;</span><br><span class="line">  latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">  std::shared_ptr&lt;Bucket&gt; p_bucket = dir_[index];</span><br><span class="line">  <span class="keyword">if</span> (p_bucket-&gt;<span class="built_in">Insert</span>(key, value)) &#123;</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入失败，桶已满，根据global depth和local depth决定是否进行目录扩张</span></span><br><span class="line">  <span class="comment">// 目录扩张</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetGlobalDepthInternal</span>() == p_bucket-&gt;<span class="built_in">GetDepth</span>()) &#123;</span><br><span class="line">    <span class="comment">// 1. 复制目录</span></span><br><span class="line">    <span class="keyword">auto</span> copy_dir = dir_;</span><br><span class="line">    <span class="comment">// 2. 拼接</span></span><br><span class="line">    dir_.<span class="built_in">insert</span>(dir_.<span class="built_in">end</span>(), copy_dir.<span class="built_in">begin</span>(), copy_dir.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 3. 增加globalDepth</span></span><br><span class="line">    <span class="built_in">IncrementGlobalDepth</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 桶分裂</span></span><br><span class="line">  <span class="comment">// 1. 创建两个新桶（depth+1）</span></span><br><span class="line">  p_bucket-&gt;<span class="built_in">IncrementDepth</span>();</span><br><span class="line">  <span class="keyword">auto</span> p_b_0 = std::<span class="built_in">make_shared</span>&lt;Bucket&gt;(bucket_size_, p_bucket-&gt;<span class="built_in">GetDepth</span>());</span><br><span class="line">  <span class="keyword">auto</span> p_b_1 = std::<span class="built_in">make_shared</span>&lt;Bucket&gt;(bucket_size_, p_bucket-&gt;<span class="built_in">GetDepth</span>());</span><br><span class="line">  <span class="comment">// 2. 重新分配桶内元素</span></span><br><span class="line">  <span class="comment">// 2.1 获取第depth位掩码</span></span><br><span class="line">  <span class="type">size_t</span> mask = <span class="number">1</span> &lt;&lt; (p_bucket-&gt;<span class="built_in">GetDepth</span>() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item : p_bucket-&gt;<span class="built_in">GetItems</span>()) &#123;</span><br><span class="line">    <span class="comment">// 2.2 根据第depth位分配给两个新桶</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">IndexOf</span>(item.first) &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">      p_b_1-&gt;<span class="built_in">Insert</span>(item.first, item.second);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p_b_0-&gt;<span class="built_in">Insert</span>(item.first, item.second);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重新分配directory指针</span></span><br><span class="line">  <span class="type">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pb : dir_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pb.<span class="built_in">get</span>() == p_bucket.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((idx &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">        pb = p_b_0;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pb = p_b_1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    idx++;</span><br><span class="line">  &#125;</span><br><span class="line">  num_buckets_++;</span><br><span class="line">  latch_.<span class="built_in">unlock</span>();</span><br><span class="line">  <span class="comment">// 递归插入</span></span><br><span class="line">  <span class="built_in">Insert</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LRU-K-Replacer"><a href="#LRU-K-Replacer" class="headerlink" title="LRU-K Replacer"></a>LRU-K Replacer</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>核心概念：<code>Backward K-distance</code> ，Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access。</p>
<p>我们有磁盘页的集合$N&#x3D;{1,2,3,..,n}$，然后给定磁盘页访问的时间序列 $r_1, r_2,…r_t$，其中$r_t &#x3D; p$表示在t时刻访问页号为p的磁盘页，那么页号p的Backward K-distance 可以表示为 $b_t(p, K)$。</p>
<p>$b_t(p, K) &#x3D; x$ ，如果 $r_{t-x}&#x3D;p$，并且在时刻t-x到t中，p出现了K次。</p>
<p>$b_t(p, K) &#x3D; +\infin$ ， 如果在 1,2,3..t 时刻中，p出现不足K次。</p>
<p>LRU-K算法就是在驱逐页面时，选择具有最大<code>Backward K-distance</code>的页。如果有多个页的<code>Backward K-distance</code>都是正无穷，那么可采取其他页面替换算法，比如LRU算法，驱逐最近不常使用的页面。</p>
<h2 id="xv6的缓存实现"><a href="#xv6的缓存实现" class="headerlink" title="xv6的缓存实现"></a>xv6的缓存实现</h2><p>在我自己的想法中，Replacer用来记录每个page的访问情况，然后调用eviect决定哪个page应该牺牲。在xv6操作系统的文件块缓存中，它是这么设计的：</p>
<img src="http://markdown.desirer233.fun/202404221453835.jpeg" style="zoom:30%;" />

<p>磁盘可以想象成块数组，每个块block有唯一的ID。bcache作为缓存，存储的是一个buf的链表。这个buf有两个属性，分别是refcnt引用计数和blockno对应的块ID。通过bcache拿块的过程就是顺序访问链表，查找有无对应ID的buf，如果没有，选择一个空白的buf，然后从磁盘上加载对应块的内容。如果没有空白的buf，就得牺牲一个refcnt为0的块。链表采用LRU算法组织，链表头部是经常使用的节点。引用计数refcnt维护了当前正在使用块的线程数量，线程get一个块会增加引用计数，release一个块会减少引用计数。当引用计数为零时，会将buf移动到链表头部，方便LRU算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">buf</span>* <span class="built_in">bget</span>(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holdingsleep</span>(&amp;b-&gt;lock))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">releasesleep</span>(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实验中的缓冲池实现"><a href="#实验中的缓冲池实现" class="headerlink" title="实验中的缓冲池实现"></a>实验中的缓冲池实现</h2><img src="http://markdown.desirer233.fun/202404221514592.jpeg" style="zoom:45%;" />

<p>实验中的replacer设计弯弯绕绕，一开始我还没明白为什么replacer管理的是frame而不是page。首先从buffer pool manager来看，它有一个<code>pages_</code>数组作为缓存，有一个哈希表<code>page_table_</code>记录page在哪个frame里。这个frame说白了就是slot，再看实现，其实就是0到$len(pages_)$的整数。</p>
<p>真的是好家伙，比方说数组大小为10，那么replacer就管理这10个整数的出现频次，所以才会有Remove方法出现。</p>
<ul>
<li>remove：Remove an evictable frame from replacer, along with its access history.</li>
</ul>
<p>为什么有remove方法？evit不就好了，而且为什么要清除一个page的access历史？</p>
<ul>
<li>RecordAccess: If frame id is invalid (ie. larger than replacer_size_), throw an exception.</li>
</ul>
<p>为什么一个大于size的frame id会违法？这在当时我是想不通的，frame id不是随机出现的page id吗？结果就是frame id只是个整数，数组的索引不能越界的限制。</p>
<p>这一切的一切，全都源自于buffer pool manager（bpm）和replaces的分离式设计！这使得引用计数的维护和牺牲页面两个功能分开了！由于replacer并不知道一个frame被用了多少次，所以不得不靠bpm来主动设置一个frame的evictable属性，避免页面被提前换出。</p>
<h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><p>（1）timestamp的实现</p>
<p>只需要在access的时候自增timestamp变量。</p>
<p>（2）pin frame的实现</p>
<p>利用一个数组记录相应frame是否固定或者将pin与frame组成一个新结构体。这是因为固定的frame解除固定后，还需要被正常追踪LRU-K。</p>
<p>（3）大小的追踪（replacer_size不是max_size）</p>
<ul>
<li>可驱逐的帧数量 replacer_size_</li>
<li>不可驱逐的帧数量 curr_size_ 减去 replacer_size_</li>
<li>最大追踪的帧数量 max_size_ （curr_size_ 小于等于 max_size_)</li>
</ul>
<p>The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is initialized to have no frames in it. Then, only when a frame is marked as evictable, replacer’s size will increase.</p>
<h2 id="实验踩坑"><a href="#实验踩坑" class="headerlink" title="实验踩坑"></a>实验踩坑</h2><p>（1）线上测试，我用自己实现的根据backward K距离牺牲页面的算法不通过。网上查看，一些是依据前第k次的时间戳排序，一些人直接将访问次数达到K次的的frame用LRU算法实现（连一个帧的access history都不需要存储，只需要记录访问次数）。</p>
<p>我修改代码为后一种方式后通过了在线测试，真是魔幻！</p>
<p>（2）死锁问题</p>
<p><code>void LRUKReplacer::RecordAccess(frame_id_t frame_id)</code> 中调用 <code>auto LRUKReplacer::Evict(frame_id_t *frame_id) -&gt; bool </code></p>
<p>由于两个函数都是一个大锁保护，造成死锁。</p>
<p>解决方法：利用一个Internal函数，解除锁的依赖。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">EvictInternal</span>(frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Buffer-pool-instance"><a href="#Buffer-pool-instance" class="headerlink" title="Buffer pool instance"></a>Buffer pool instance</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><img src="http://markdown.desirer233.fun/202404221514592.jpeg" style="zoom:45%;" />

<p>首先，从Buffer pool的使用者上来看，Buffer pool最主要的功能就是查找页<code>FetchPg(page_id_t page_id)</code>和新建页<code>NewPg(page_id_t *page_id)</code>。上层使用者希望通过一个page id得到对应的页内容，或者希望插入一些新数据（需要得到一个空页）。</p>
<p>从Buffer pool里面来看，有一块连续的地址空间<code>Page *pages_;</code>用来存Page，但是Page在这块空间可能是分散存放的（写回一个脏页时，该位置上的Page不再使用，可以被覆盖。Buffer pool不作内存整理）。对应的，有一个<code>ExtendibleHashTable&lt;page_id_t, frame_id_t&gt; *page_table</code>的哈希表，维护着page id 与 page index（page 在数组中的位置）的映射。这个page index表现为frame id。怎么理解呢？帧（frame）相当于快递盒子，页（page）作为物品放置于快递盒子中。缓冲池管理固定个数的盒子，比如10个盒子。于是有一个空闲链表<code>std::list&lt;frame_id_t&gt; free_list</code> 追踪空盒子。</p>
<ul>
<li>通过页找到帧  <code>PageTable</code></li>
<li>通过帧找到页 <code>pages_[frame_id]</code></li>
</ul>
<p>当所有盒子都满了时，由<code>LRUKReplacer *replacer_</code>决定哪一个盒子应该置空，盒子本身是重复使用的。LRUK算法根据最近K次使用盒子时间来决定哪个盒子应该置空。</p>
<h2 id="实现注意点"><a href="#实现注意点" class="headerlink" title="实现注意点"></a>实现注意点</h2><p>（1）基本逻辑</p>
<p>FetchPg的逻辑</p>
<p>首先在缓冲池pages_里查找，如果找到了，更新访问记录并返回。如果未找到，那么我们需要一个帧来装这个页，优先从空帧中找，否则需要牺牲一个帧。然后通过DiskManager装载Page的内容，最后更新访问记录并返回。</p>
<p>NewPg的逻辑</p>
<p>首先需要找到一个帧来装载Pg。从空帧链表中找或者牺牲一个帧。然后通过<code>AllocatePage()</code>分配一个新页，将页装在帧上，更新访问记录并返回。</p>
<p>（2）牺牲帧时的操作</p>
<p>牺牲得到帧里面的页可能是Dirty的，需要写回到磁盘，同时解除页与帧的映射关系。</p>
<p>（3）Unpin时，页的diry设置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pages_[frame_id].is_dirty_ = pages_[frame_id].is_dirty_ || is_dirty; </span><br></pre></td></tr></table></figure>

<p>不可能从脏页变成干净页。只有刷新页的时候才会设置干净页。</p>
<p>（4）小心维护引用计数和Replacer的分离设计</p>
<p>引用计数和Replacer相互分离，需要额外通过设置evictable属性避免引用计数大于零的页面被驱逐。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">  <span class="keyword">if</span> (!page_table_-&gt;<span class="built_in">Find</span>(page_id, frame_id)) &#123;</span><br><span class="line">    <span class="comment">// 未找到页面，分配新帧</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetFrame</span>(&amp;frame_id)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">    pages_[frame_id].pin_count_++;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到页面，更新访问次数</span></span><br><span class="line">	...</span><br><span class="line">  pages_[frame_id].pin_count_++;</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个后果就是：这两个语句需要绑定在一起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages_[frame_id].pin_count_++;</span><br><span class="line">replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>实验P1</p><p><a href="https://xyz.desirer233.fun/2024/04/15/cmu15445/lab/实验p1/">https://xyz.desirer233.fun/2024/04/15/cmu15445/lab/实验p1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-04-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-05-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/04/15/cmu15445/lab/%E5%AE%9E%E9%AA%8Cp0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">实验P0</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/04/12/cmu15445/Lec04/"><span class="level-item">cmu15-445笔记四 哈希表</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Extendible-hash-table"><span class="level-left"><span class="level-item">1</span><span class="level-item">Extendible hash table</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#注意点"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">注意点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#LRU-K-Replacer"><span class="level-left"><span class="level-item">2</span><span class="level-item">LRU-K Replacer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#xv6的缓存实现"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">xv6的缓存实现</span></span></a></li><li><a class="level is-mobile" href="#实验中的缓冲池实现"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">实验中的缓冲池实现</span></span></a></li><li><a class="level is-mobile" href="#注意点-1"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">注意点</span></span></a></li><li><a class="level is-mobile" href="#实验踩坑"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">实验踩坑</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Buffer-pool-instance"><span class="level-left"><span class="level-item">3</span><span class="level-item">Buffer pool instance</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理-2"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#实现注意点"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">实现注意点</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cmu15445/"><span class="level-start"><span class="level-item">cmu15445</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/cmu15445/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/muduo%E7%BD%91%E7%BB%9C%E5%BA%93/"><span class="level-start"><span class="level-item">muduo网络库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/GDB/"><span class="level-start"><span class="level-item">GDB</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/IDE/"><span class="level-start"><span class="level-item">IDE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="level-start"><span class="level-item">命令行</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"><span class="level-start"><span class="level-item">PostgreSQL</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/openGauss/"><span class="level-start"><span class="level-item">openGauss</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/"><span class="level-start"><span class="level-item">计算机工程</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>