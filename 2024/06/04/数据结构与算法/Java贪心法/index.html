<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>贪心法总结 - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="贪心算法，以一个局部最优来靠近全局最优。"><meta property="og:type" content="blog"><meta property="og:title" content="贪心法总结"><meta property="og:url" content="https://xyz.desirer233.fun/2024/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E8%B4%AA%E5%BF%83%E6%B3%95/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="贪心算法，以一个局部最优来靠近全局最优。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791-20230310133845522.png"><meta property="article:published_time" content="2024-06-04T06:00:00.000Z"><meta property="article:modified_time" content="2024-06-09T12:54:14.752Z"><meta property="article:author" content="Desirer"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2024/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E8%B4%AA%E5%BF%83%E6%B3%95/"},"headline":"贪心法总结","image":["https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png","https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791-20230310133845522.png"],"datePublished":"2024-06-04T06:00:00.000Z","dateModified":"2024-06-09T12:54:14.752Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"贪心算法，以一个局部最优来靠近全局最优。"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2024/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E8%B4%AA%E5%BF%83%E6%B3%95/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-04T06:00:00.000Z" title="2024/6/4 14:00:00">2024-06-04</time>发表</span><span class="level-item"><time dateTime="2024-06-09T12:54:14.752Z" title="2024/6/9 20:54:14">2024-06-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><span class="level-item">25 分钟读完 (大约3735个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">贪心法总结</h1><div class="content"><p>贪心算法，以一个局部最优来靠近全局最优。</p>
<span id="more"></span>

<h1 id="一周目-开胃小菜"><a href="#一周目-开胃小菜" class="headerlink" title="一周目 开胃小菜"></a>一周目 开胃小菜</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p>
<p>很简单的思路，饼干和胃口排序。升序，类似合并链表。小饼干满足小胃口。</p>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">https://leetcode.cn/problems/wiggle-subsequence/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//-1 下降 1上升 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guard</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 哨兵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;guard)&#123;</span><br><span class="line">                <span class="keyword">if</span>(period==-<span class="number">1</span> || period==<span class="number">0</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    period = <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;guard)&#123;</span><br><span class="line">                <span class="keyword">if</span>(period==<span class="number">1</span> || period==<span class="number">0</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    period = -<span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            guard = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>贪心法：考虑坡度，上坡取头尾两个数，平坡合并为一个数，下坡也只取头尾。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png" style="zoom:25%;" />

<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></li>
</ul>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">- 输出: 6</span><br><span class="line">- 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</span><br></pre></td></tr></table></figure>

<p>贪心法：从左到右，类似滑动窗口。窗口内和大于0仍旧右移。如果窗口内和小于0，窗口从下一个数字开始（left移到i+1）。</p>
<p><strong>思考贪心法的正确性：假设最大和的连续子数组左下标为left，右下标为right。那么 任何在0，left-1这段区间内，以left-1为右边界的连续子数组的和都不会大于0。（否则最大和的连续子数组可以拓展），那么这个滑动窗口必然覆盖到解！</strong></p>
<h1 id="二周目-贪心的递归（状态转移）"><a href="#二周目-贪心的递归（状态转移）" class="headerlink" title="二周目 贪心的递归（状态转移）"></a>二周目 贪心的递归（状态转移）</h1><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 当天买，如果第二天价格高就卖，否则换成第二天买</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hold</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;hold)&#123;</span><br><span class="line">                ans += nums[i]-hold; </span><br><span class="line">                hold = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt; hold)&#123;</span><br><span class="line">                hold = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心思路：可以把第x天买，第y天卖，拆成每天一卖。</p>
<p>我们希望获得每个“上坡”的收益，如果第二天价格更高，那就卖。如果第二天价格低，那就放弃第一天的买入。</p>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//覆盖范围, 初始覆盖范围应该是0，因为下面的迭代是从下标0开始的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coverRange</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在覆盖范围内更新最大的覆盖范围</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= coverRange; i++) &#123;</span><br><span class="line">            coverRange = Math.max(coverRange, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (coverRange &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心思路： 每次取能跳跃的最右边界。在这左右边界内，取能跳到的最右边，作为下一个右边界。下一个左边界为当前右边界+1.</p>
<h2 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></li>
</ul>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span><span class="number">0</span>, end =nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">farest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;nums.length-<span class="number">1</span>)&#123; <span class="comment">//当前未到达最后一个元素</span></span><br><span class="line">            <span class="comment">// 求在begin，end区间能达到的最远距离</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=begin; i&lt;=end; ++i)&#123;</span><br><span class="line">                farest = Math.max(farest, i+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            begin = end;</span><br><span class="line">            end = farest;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>辨析：这次要求用最少的跳跃次数。和上题思路一致，当前区间找下一个区间的最大覆盖。只不过上题是一步一步走，这次要精确的跳到最大覆盖。</p>
<h1 id="三周目-贪心策略"><a href="#三周目-贪心策略" class="headerlink" title="三周目 贪心策略"></a>三周目 贪心策略</h1><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></li>
</ul>
<p>将油量减去消耗量，得到一个数组。如果这个数组和为0，肯定不能环绕一圈。问题是，如果数组和大于等于0，一定能环绕一圈吗？</p>
<p><strong>证明：数组和大于0，必定存在一个区间和大于0的区间（否则所有区间和都小于0，数组和小于0，矛盾）。这里的区间指尽可能往左右延伸，使得区间和大于零。</strong></p>
<ul>
<li>如果只存在一个区间和大于0的区间，从这个区间起点出发，必定能环绕一周。</li>
<li>如果存在多个区间和大于0的区间。（不存在）<ul>
<li>我们找长度最短的区间I，且I的和大于等于0.这个区间的左右均为负数。</li>
<li>所有区间+左边元素，必定和小于0，矛盾</li>
</ul>
</li>
</ul>
<p>因此只要找到区间和大于0的区间就行。</p>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">https://leetcode.cn/problems/candy/</a></li>
</ul>
<p>这题比较有趣，引出了一个策略：多次贪心。</p>
<p>第一次贪心：从左到右。使得每个孩子与它左边的孩子满足题目要求。</p>
<p>第二次贪心：从右到左。使得每个孩子与它右边的孩子满足题目要求。</p>
<p>这样两边的要求就都满足了。</p>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">https://leetcode.cn/problems/queue-reconstruction-by-height/</a></li>
</ul>
<p>这题很有意思，知道每个人的身高，以及多少个人的身高比它高。&lt;身高，序列号&gt;</p>
<p>自然而然想到排序。按什么排序呢？升序还是降序？</p>
<p>如果按序列号排，序列号小的排前面，序列号大的排后面。后续怎么调整？虽然说这样满足了一些序列号的性质。</p>
<p>按身高排序，从高到低。那么即使后面的人插入前面的人的队列中，前面的人的序列号也不会受到影响（因为后面的人的身高低），这样就提供了一种可供调整的方式。</p>
<h2 id="重排字符串"><a href="#重排字符串" class="headerlink" title="重排字符串"></a>重排字符串</h2><p>给定一个字符串 <code>s</code> ，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorganize-string/description/">https://leetcode.cn/problems/reorganize-string/description/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reorganizeString</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] alphabetArr = S.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] alphabetCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            alphabetCount[alphabetArr[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, alphabet = <span class="number">0</span>, threshold = (length + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; alphabetCount.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alphabetCount[i] &gt; max) &#123;</span><br><span class="line">                max = alphabetCount[i];</span><br><span class="line">                alphabet = i;</span><br><span class="line">                <span class="keyword">if</span> (max &gt; threshold) <span class="comment">// 无法构成</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造返回字符串</span></span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (alphabetCount[alphabet]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[index] = (<span class="type">char</span>) (alphabet + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            index += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; alphabetCount.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (alphabetCount[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= res.length) &#123;</span><br><span class="line">                    index = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res[index] = (<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                index += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题首先的想法就是获取每个字符的个数。</p>
<p>最初的想法，我先取出个数最多的字符，排成一列。再将其他字符填进去。虽然这个思路成功得出，如果存在个数大于总数一半的字符，则无法构成题目要求的字符串。但后续思路却并不好想，当字符个数接近平均时，后续怎么放字符？</p>
<p>正确的思考方向是从整体考虑：字符串有多长，坑位就有多少个。坑位是定的。前一种思考方法，坑位是不定的。</p>
<p>（1）为了达到不相邻的效果，字符肯定是隔一位置放一个，那么刚开始怎么放？放第一个位置还是第二个位置？</p>
<p>（2）从奇数位置个数总是大于等于偶数位值个数（下标从1开始），从第一个位置开始放比较好点。</p>
<p>思路：将字符个数排降序，从最多的字符开始，从第一个位置开始，隔一个放一个。奇数位置放满后，放偶数位置。</p>
<h2 id="多数元素2"><a href="#多数元素2" class="headerlink" title="多数元素2"></a>多数元素2</h2><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element-ii/">https://leetcode.cn/problems/majority-element-ii/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candidate = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] vote = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidate[<span class="number">0</span>]==num)&#123;</span><br><span class="line">                vote[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(candidate[<span class="number">1</span>]==num)&#123;</span><br><span class="line">                vote[<span class="number">1</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vote[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                candidate[<span class="number">0</span>]=num;</span><br><span class="line">                vote[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vote[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                candidate[<span class="number">1</span>]=num;</span><br><span class="line">                vote[<span class="number">1</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 相消，放入抽屉</span></span><br><span class="line">                vote[<span class="number">0</span>]--;</span><br><span class="line">                vote[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vote[<span class="number">0</span>]&gt;<span class="number">0</span> &amp;&amp; candidate[<span class="number">0</span>]==num)</span><br><span class="line">                count[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(vote[<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; candidate[<span class="number">1</span>]==num)</span><br><span class="line">                count[<span class="number">1</span>]++;</span><br><span class="line">        &#125; </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(vote[<span class="number">0</span>]&gt;<span class="number">0</span> &amp;&amp; count[<span class="number">0</span>]&gt; nums.length/<span class="number">3</span>)</span><br><span class="line">            ans.add(candidate[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(vote[<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; count[<span class="number">1</span>]&gt; nums.length/<span class="number">3</span>)</span><br><span class="line">            ans.add(candidate[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看一道相关题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/description/">lc 169 众数</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  采用摩尔投票算法，只需遍历一遍数组就能知道众数。</p>
<p>怎么从「摩尔投票法」拓展到多数元素2？将消除的过程从一个坑位拓展到两个坑位！</p>
<blockquote>
<p>个人理解摩尔投票法本质上就是宾果消消乐游戏，每次消除3个不同的数。由于数组长度为n，因此消消乐最多进行[n&#x2F;3]次。因此，我们想要的答案（超过[n&#x2F;3]的数字）一定没有被消除完，一定存在最后活下来的两个数当中。 但是，存活的两个数不一定都是想要的真正的答案，最后再遍历确认一下这两个数是不是答案即可。</p>
</blockquote>
<p>证明的核心就是抽屉原理。（抽屉原理：N+1个苹果放在N个抽屉，至少有一个抽屉有2个及以上的苹果）</p>
<p>（1）众数</p>
<p>相消的过程其实就是提取一个相异元素对的过程。我们可以构造容量为2的抽屉，这个抽屉只能放不同的元素。</p>
<p>有多少个抽屉？最多 <code>⌊ n/2 ⌋</code>个罢了。而我们知道，众数是超过  <code>⌊ n/2 ⌋</code>个的，每个抽屉最多放1个众数，</p>
<p>最后留下来的自然就是众数。</p>
<p>（2）超过 <code>⌊ n/3 ⌋</code> 次的元素</p>
<p>其实上面的过程还有一个逻辑，就是众数只有1个。回到本题，超过 <code>⌊ n/3 ⌋</code> 次的元素（这里称之为次众数吧）最多只有2个（证明过程留给读者）。</p>
<p>我们可以仿造上面的证明过程，构造容量为3的抽屉，每个抽屉中的元素互不相同，最多有 <code>⌊ n/3 ⌋</code>个抽屉。那么超过 <code>⌊ n/3 ⌋</code>的元素自然在相消的过程中留了下来。</p>
<p>算法：构造容量为2的候选集，遍历数组元素，如果当前元素与候选集都不同，则互相消去（放入一个抽屉）。如果当前元素与候选集中的一个元素相同，则那个元素的计数加一。最后检验候选集里的元素是否满足要求。</p>
<p>时间复杂度O（N），空间复杂度O（1）。</p>
<p>（3）拓展：超过 <code>⌊ n/k ⌋</code>的元素</p>
<p>算法：构造容量为k-1的候选集，重复上面所述的遍历行为，最后检验一下。</p>
<p>证明：依然是构造容量为k的抽屉，每个抽屉中的元素互不相同，最多有 <code>⌊ n/k ⌋</code>个抽屉。那么超过 <code>⌊ n/k ⌋</code>的元素自然在相消的过程中留了下来。</p>
<h1 id="四周目-区间贪心"><a href="#四周目-区间贪心" class="headerlink" title="四周目 区间贪心"></a>四周目 区间贪心</h1><h2 id="区间贪心原理"><a href="#区间贪心原理" class="headerlink" title="区间贪心原理"></a>区间贪心原理</h2><p><strong>区间不相交问题：给定N个开区间，找出尽可能多的开区间，两两不相交。</strong></p>
<p><strong>区间选点问题：给定N个闭区间，确定最少需要几个点，使得每个闭区间都覆盖到点。</strong></p>
<h3 id="区间不相交问题"><a href="#区间不相交问题" class="headerlink" title="区间不相交问题"></a>区间不相交问题</h3><p>（1）排序</p>
<p>区间贪心总是要先排序，假设按照左端点升序排序。</p>
<p>（2）从区间包含讲起</p>
<p>如果区间A包含区间B，那么选不相交的区间时，肯定选B，因为B更小，能够让出更多的空间。<strong>在刨除了区间包含的情况后，此时各区间的情况是类似阶梯形。</strong></p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791-20230310133845522.png" style="zoom:33%;" />

<p>考虑第一段区间的左端点到第二段区间的左端点部分，这一部分是肯定没有重叠的。考虑去掉它，那么第一段区间就包含第二段区间内了，这时候肯定选第一段区间。</p>
<p>（3）策略</p>
<p><strong>按照区间左端点排序，然后总是选择右端点最小的区间。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区间不相交问题模版</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>; <span class="comment">//选中初始区间</span></span><br><span class="line"><span class="type">int</span> last_y = I[<span class="number">0</span>].y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; ++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(I[i].x &gt;= last_y)&#123; </span><br><span class="line">		last_y = I[i].y; <span class="comment">//更新区间的最右端点</span></span><br><span class="line">    ans++;	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间选点问题"><a href="#区间选点问题" class="headerlink" title="区间选点问题"></a>区间选点问题</h3><p>区间选点问题也是同样的，如果存在区间包含的情况，选择被包含的区间，因为它覆盖到了更多的区间。</p>
<p>排序过后，对于第一段相交区间，选哪个点能够让它覆盖尽可能多的区间？是第一个区间的右端点还是第二个区间的左端点？当然是第一个区间的右端点，因为它更靠右，能够覆盖更多区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区间选点问题模版</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> last_y = I[<span class="number">0</span>].y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; ++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(I[i].x &gt; last_y)&#123; <span class="comment">//此时区间不相交</span></span><br><span class="line">		last_y = I[i].y; </span><br><span class="line">    ans++;	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最少数量的箭引爆气球"><a href="#最少数量的箭引爆气球" class="headerlink" title="最少数量的箭引爆气球"></a>最少数量的箭引爆气球</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// 对points按照左端点升序排序</span></span><br><span class="line">        Arrays.sort(points, (a1, a2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a1[<span class="number">0</span>] == a2[<span class="number">0</span>]) <span class="keyword">return</span> a1[<span class="number">1</span>] &gt; a2[<span class="number">1</span>] ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> a1[<span class="number">0</span>] &gt; a2[<span class="number">0</span>] ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="comment">// System.out.println(Arrays.deepToString(points));</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last_y</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;points.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 判断区间是否相交</span></span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; last_y)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                last_y = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//总是选右端点小的那个,去除包含情况</span></span><br><span class="line">                last_y = Math.min(last_y, points[i][<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是找最多的不相交区间。不相交的区间都需要一只箭射。其他与之相交的区间可以通过调箭的位置使之射中。</p>
<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Integer内置比较方法，不会溢出</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last_y</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;intervals.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= last_y)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                last_y = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last_y = Math.min(last_y, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>思路：其实就是找最多不相交区间。区间总数减去这个数就是要移除的区间数目。</p>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">       Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">       List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;intervals.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; right)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            right = Math.max(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">       &#125; </span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是贪心思路，相交区间一直合并，直到遇到不相交的区间。</p>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">https://leetcode.cn/problems/partition-labels/</a></li>
</ul>
<p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">- 输出：[9,7,8] </span><br><span class="line">- 解释： 划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。 每个字母最多出现在一个片段中。 像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//有点像跳跃区间,jump[i] 记录字母i最后出现的位置</span></span><br><span class="line">        <span class="type">int</span>[] jump = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length();++i)&#123;</span><br><span class="line">            jump[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 以l，r区间开始查找</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">            r = Math.max(r, jump[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i==r)&#123;</span><br><span class="line">                list.add(r-l+<span class="number">1</span>);</span><br><span class="line">                l = r+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：这道题类似合并区间。将每个字母第一次出现的位置看成区间的左端点，最后一次出现的位置看成区间的右端点。那么重叠的区间就必须合并（否则一个字母出现在两个划分中）。</p>
<p>具体实现有技巧。</p>
<ul>
<li><p>统计每一个字符最后出现的位置</p>
</li>
<li><p>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</p>
</li>
</ul>
<h1 id="五周目"><a href="#五周目" class="headerlink" title="五周目"></a>五周目</h1><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/description/">https://leetcode.cn/problems/monotone-increasing-digits/description/</a></p>
<p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>从后往前调整，如果k+1位的数字小于第k位的数字，那么调整第k+1位的数字为9，第k位数字减一。重复这个过程，直至遍历完。</p>
<h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/">https://leetcode.cn/problems/binary-tree-cameras/</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个贪心策略就是：隔一层放一个摄像头。让叶子结点的父亲放置摄像头。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>贪心法总结</p><p><a href="https://xyz.desirer233.fun/2024/06/04/数据结构与算法/Java贪心法/">https://xyz.desirer233.fun/2024/06/04/数据结构与算法/Java贪心法/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-06-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-06-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/%E5%9D%87%E5%80%BC%E4%B8%BAuv%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">均值为u/v的子数组</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%9B%9E%E6%BA%AF%E6%B3%95/"><span class="level-item">回溯法总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一周目-开胃小菜"><span class="level-left"><span class="level-item">1</span><span class="level-item">一周目 开胃小菜</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分发饼干"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">分发饼干</span></span></a></li><li><a class="level is-mobile" href="#摆动序列"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">摆动序列</span></span></a></li><li><a class="level is-mobile" href="#最大子序和"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">最大子序和</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二周目-贪心的递归（状态转移）"><span class="level-left"><span class="level-item">2</span><span class="level-item">二周目 贪心的递归（状态转移）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#买卖股票的最佳时机"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">买卖股票的最佳时机</span></span></a></li><li><a class="level is-mobile" href="#跳跃游戏"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">跳跃游戏</span></span></a></li><li><a class="level is-mobile" href="#跳跃游戏2"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">跳跃游戏2</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三周目-贪心策略"><span class="level-left"><span class="level-item">3</span><span class="level-item">三周目 贪心策略</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#加油站"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">加油站</span></span></a></li><li><a class="level is-mobile" href="#分发糖果"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">分发糖果</span></span></a></li><li><a class="level is-mobile" href="#根据身高重建队列"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">根据身高重建队列</span></span></a></li><li><a class="level is-mobile" href="#重排字符串"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">重排字符串</span></span></a></li><li><a class="level is-mobile" href="#多数元素2"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">多数元素2</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四周目-区间贪心"><span class="level-left"><span class="level-item">4</span><span class="level-item">四周目 区间贪心</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#区间贪心原理"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">区间贪心原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#区间不相交问题"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">区间不相交问题</span></span></a></li><li><a class="level is-mobile" href="#区间选点问题"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">区间选点问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最少数量的箭引爆气球"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">最少数量的箭引爆气球</span></span></a></li><li><a class="level is-mobile" href="#无重叠区间"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">无重叠区间</span></span></a></li><li><a class="level is-mobile" href="#合并区间"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">合并区间</span></span></a></li><li><a class="level is-mobile" href="#划分字母区间"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">划分字母区间</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五周目"><span class="level-left"><span class="level-item">5</span><span class="level-item">五周目</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#单调递增的数字"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">单调递增的数字</span></span></a></li><li><a class="level is-mobile" href="#监控二叉树"><span class="level-left"><span class="level-item">5.1.2</span><span class="level-item">监控二叉树</span></span></a></li></ul></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CMU15445/"><span class="level-start"><span class="level-item">CMU15445</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E7%BB%88%E7%AB%AF/"><span class="level-start"><span class="level-item">终端</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>