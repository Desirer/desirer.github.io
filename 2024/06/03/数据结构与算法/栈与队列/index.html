<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>栈与队列算法总结 - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="栈、单调栈、队列、单调队列"><meta property="og:type" content="blog"><meta property="og:title" content="栈与队列算法总结"><meta property="og:url" content="https://xyz.desirer233.fun/2024/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="栈、单调栈、队列、单调队列"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg"><meta property="og:image" content="https://img-blog.csdnimg.cn/029a571dc91344699b56b9cb449fbadb.png"><meta property="article:published_time" content="2024-06-03T11:00:00.000Z"><meta property="article:modified_time" content="2024-11-22T08:35:35.000Z"><meta property="article:author" content="Desirer"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2024/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},"headline":"栈与队列算法总结","image":["https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg","https://img-blog.csdnimg.cn/029a571dc91344699b56b9cb449fbadb.png"],"datePublished":"2024-06-03T11:00:00.000Z","dateModified":"2024-11-22T08:35:35.000Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"栈、单调栈、队列、单调队列"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2024/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-03T11:00:00.000Z" title="2024/6/3 19:00:00">2024-06-03</time>发表</span><span class="level-item"><time dateTime="2024-11-22T08:35:35.000Z" title="2024/11/22 16:35:35">2024-11-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/">数组与字符串</a></span><span class="level-item">17 分钟读完 (大约2616个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">栈与队列算法总结</h1><div class="content"><p>栈、单调栈、队列、单调队列</p>
<span id="more"></span>

<h1 id="Java中栈的使用"><a href="#Java中栈的使用" class="headerlink" title="Java中栈的使用"></a>Java中栈的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的栈对象</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入栈操作</span></span><br><span class="line">        stack.push(<span class="number">10</span>);</span><br><span class="line">        stack.push(<span class="number">20</span>);</span><br><span class="line">        stack.push(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出栈操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">topElement</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(<span class="string">&quot;出栈元素：&quot;</span> + topElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取栈顶元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">peekElement</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素：&quot;</span> + peekElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断栈是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;栈是否为空：&quot;</span> + isEmpty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取栈的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;栈的大小：&quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入栈push、出栈pop、栈顶peek、判空isEmpty、大小size</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span> || ch==<span class="string">&#x27;[&#x27;</span> || ch==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">               stk.push(ch); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch ==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stk.isEmpty() &amp;&amp; stk.peek() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    stk.pop(); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch ==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stk.isEmpty() &amp;&amp; stk.peek() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    stk.pop(); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch ==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stk.isEmpty() &amp;&amp; stk.peek() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    stk.pop(); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.isEmpty() ? <span class="literal">true</span>:<span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/">https://leetcode.cn/problems/backspace-string-compare/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch ==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stk.isEmpty()) stk.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                stk.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hs</span> <span class="operator">=</span> handle(s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ht</span> <span class="operator">=</span> handle(t);</span><br><span class="line">        <span class="keyword">return</span> hs.equals(ht) ? <span class="literal">true</span>:<span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stk.isEmpty() &amp;&amp; stk.peek()==ch)&#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="逆波兰式求值"><a href="#逆波兰式求值" class="headerlink" title="逆波兰式求值"></a>逆波兰式求值</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;tokens.length; ++i)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokens[i];</span><br><span class="line">            <span class="keyword">if</span>(token.equals(<span class="string">&quot;+&quot;</span>) || token.equals(<span class="string">&quot;-&quot;</span>) || token.equals(<span class="string">&quot;*&quot;</span>) || token.equals(<span class="string">&quot;/&quot;</span>) )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;+&quot;</span>)) stk.push(n+m);</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;-&quot;</span>)) stk.push(n-m);</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;*&quot;</span>)) stk.push(n*m);</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;/&quot;</span>)) stk.push(n/m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stk.push(Integer.valueOf(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇数字入栈，遇符号出栈。逆波兰式本身就是后序遍历。</p>
<h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stkIn;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stkOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stkIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stkOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stkIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stkOut.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stkIn.isEmpty()) stkOut.push(stkIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stkOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stkOut.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stkIn.isEmpty()) stkOut.push(stkIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stkOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stkIn.isEmpty() &amp;&amp; stkOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个栈，一个栈用于填入元素，另一个栈用于弹出元素。当要弹出元素时，将第一个栈的元素倒入第二个栈中，自然形成了先进先出的顺序。</p>
<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// res存字符串解码的内容，即无【】</span></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; num_stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 数字栈</span></span><br><span class="line">        Stack&lt;String&gt; ch_stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">// 字符栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                num = <span class="number">10</span>*num + ch-<span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                num_stk.push(num);</span><br><span class="line">                ch_stk.push(res.toString());  <span class="comment">// 将【之前的，已经解码完毕的字符入栈</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> num_stk.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) tmp.append(res); <span class="comment">// 重复cnt次res的内容</span></span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(ch_stk.pop() + tmp.toString()); <span class="comment">// 【】之间内容解码完毕，与【之前的拼接</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题难点在于处理多位数字以及处理解码的语义。</p>
<p>在实现中，借助两个栈，数字栈和字符栈；同时利用一个局部变量存储当前解码内容。</p>
<p>比如“8[7[a6[bc]]]“，数字栈的使用也是因为会出现数字嵌套的情形。</p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>单调栈就是维护一个单调递增或递减的栈。</p>
<p><strong>那么，它有什么用？求下一个更大的数，就要想到单调栈。</strong></p>
<p>在使用单调栈的时候首先要明确如下两点：</p>
<ol>
<li><p>单调栈里存放的元素是什么？是元素的下标还是元素本身。</p>
</li>
<li><p>单调栈里元素是递增呢？ 还是递减呢？</p>
</li>
</ol>
<h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] tem) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[tem.length];</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;tem.length; ++i)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; tem[i]&gt; tem[stk.peek()])&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">               ans[k] = i-k;</span><br><span class="line">           &#125; </span><br><span class="line">           stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>暴力做法是直接对每个元素后面的元素进行扫描，找到第一个更大的元素为止。这种做法时间复杂度是N^ 2，因为它没有考虑到每次扫描留下的信息。一次扫描后，我们就知道了整个数组的信息，但暴力法在求后一个元素的更大元素时，还是装作什么都不知道，重新再往后扫描一遍。</p>
<p>有什么办法能留住扫描的信息？有，用一个栈来记录我们遍历过的元素，维持单调递减的顺序。<strong>从另外一个角度出发，当前元素是哪一个元素的“下一个更大的元素”？</strong></p>
<p>采用单调栈的算法，遍历到第k个元素时，更新的是k之前的元素的答案。当栈里的元素被弹出时，它就遇到了下一个更大的元素。</p>
<h2 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// nums1 实际上是查询集</span></span><br><span class="line">        <span class="comment">// 哈希映射表，元素值和位置映射</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2.length; ++i)&#123;</span><br><span class="line">            map.put(nums2[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 求next greater number</span></span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums2.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123; <span class="comment">//倒序遍历</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; stk.peek()&lt;=nums2[i])&#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = stk.isEmpty()?-<span class="number">1</span>:stk.peek();</span><br><span class="line">            stk.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1.length; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums1[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(num);</span><br><span class="line">            nums1[i] = ans[value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大的元素2"><a href="#下一个更大的元素2" class="headerlink" title="下一个更大的元素2"></a>下一个更大的元素2</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">https://leetcode.cn/problems/next-greater-element-ii/description/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(ret, -<span class="number">1</span>);</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i % n]) &#123;</span><br><span class="line">                ret[stack.pop()] = nums[i % n];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目大意：循环数组的下一个更大元素。</p>
<p>朴素的想法，将数组扩大一倍，然后应用单调栈算法实现。在更新答案时，下标映射回原来下标。</p>
<p><strong>但是不必实际扩大数组，采用取模运算。</strong></p>
<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p>
<p>（1）暴力思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//left[i] is the highest height from 0 to i</span></span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">// right[i] is the highest hegith from i to n</span></span><br><span class="line">        left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        right[N-<span class="number">1</span>] = height[N-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; ++i)&#123;</span><br><span class="line">            left[i] = Math.max(height[i], left[i-<span class="number">1</span>]);</span><br><span class="line">            right[N-<span class="number">1</span>-i] = Math.max(height[N-<span class="number">1</span>-i], right[N-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">locHeight</span> <span class="operator">=</span> Math.min(left[i-<span class="number">1</span>], right[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>( height[i] &gt; locHeight)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += (locHeight - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接雨水的本质是什么？这道题是一个数组的有条件计算，计算数组的两个大数之间凹陷的面积。最简单的思路：找出所有凹陷的面积，然后相加。</p>
<p>问题拆解：</p>
<ul>
<li>一个凹陷的面积怎么计算？</li>
<li>怎么识别一个凹陷？</li>
</ul>
<p>不能指望一个公式计算出凹陷的面积。拆分来看，要么横着算，要么竖着计算。</p>
<p>显然竖着计算比较简单。第k个位置，如果两边有比它大的数，说明它处在一个凹陷处，雨水的高度取决于两边最高的墙的最低那个。在计算雨水高度时，还可以利用动态规划加速。</p>
<p>由于每次都要遍历计算一个数两边比它大的数，可以考虑用数组存起来。</p>
<ul>
<li>left[i] 计算从0到i最大的数</li>
<li>right[i]计算从i到n最大的数</li>
</ul>
<p>总体时间复杂度O（N）。</p>
<p>（2）单调栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">// 单调栈 水平计算</span></span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt; height.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; height[i]&gt;=height[stk.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> height[stk.peek()];</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">if</span>(!stk.isEmpty() )&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - stk.peek() -<span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[i],height[stk.peek()])-mid;</span><br><span class="line">                    ans += w*h; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>水平计算，矩形水体的长度就是下一个更大的数。怎么理解？当前第k个位置是开始，那么长度就是nextGreate（k）-k。</p>
<p>那么高度怎么计算？高度就是<code>Math.min(height[i],height[stk.peek()])-mid;</code> 相当于两边最高的最低。</p>
<h2 id="柱状图最大矩形"><a href="#柱状图最大矩形" class="headerlink" title="柱状图最大矩形"></a>柱状图最大矩形</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">        <span class="comment">// first lower / next lower</span></span><br><span class="line">        <span class="comment">// 往右找第一个小于等于自己的数的下标的距离，若无，为到右边界的距离</span></span><br><span class="line">        <span class="comment">// 往左找第一个小于等于自己的数的下标的距离，若无，为到左边界的距离</span></span><br><span class="line">        <span class="type">int</span>[] rLow = <span class="keyword">new</span> <span class="title class_">int</span>[h.length];</span><br><span class="line">        <span class="type">int</span>[] lLow = <span class="keyword">new</span> <span class="title class_">int</span>[h.length];</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">//递增单调栈，重复利用</span></span><br><span class="line">        <span class="comment">// for right next lower</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;h.length;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; h[i]&lt;h[stk.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">                rLow[val] = i-val;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">            rLow[val] = h.length-val; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for left next lower  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; h[i]&lt;h[stk.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">                lLow[val] = val-i;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">            lLow[val] = val+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// now walk through every column</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(rLow));</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(lLow));</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;h.length; ++i)&#123;</span><br><span class="line">            ans = Math.max(ans, (rLow[i]+lLow[i]-<span class="number">1</span>)*h[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" style="zoom:67%;" />

<p>这题其实与接雨水类似，垂直计算每一个尽可能大的矩形面积。固定矩形的高度为当前元素的值，那么要获取大面积的矩形，则将宽度向两边延伸，自然求下一个更小的数。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; que1;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; que2; <span class="comment">//2用作缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(!que1.isEmpty())&#123;</span><br><span class="line">           que2.add(que1.remove());</span><br><span class="line">       &#125; </span><br><span class="line">       que1.add(x);</span><br><span class="line">       <span class="keyword">while</span>(!que2.isEmpty())&#123;</span><br><span class="line">           que1.add(que2.remove());</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/029a571dc91344699b56b9cb449fbadb.png" style="zoom:45%;" />

<p>用队列模拟栈，用到了两个队列。这里的思路是：让元素在一个队列内保持栈的排列。利用辅助队列使得第一个队列的队头成为栈头。</p>
<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>维护元素单调递减或单调递增的队列就是单调队列。</p>
<p>主要应用场景： 求滑动窗口的最大最小值。</p>
<p>主要思想：<strong>队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p>
<p>代码：</p>
<ul>
<li>入队时，将元素与队尾元素比较，直到适合它的位置（保持单调）。</li>
<li>出队时，将滑动窗口最左侧的元素和单调队列队首元素比较，如果是同一个元素就直接出队，否则不用操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; val &gt; deque.peekLast()) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offer(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; val == deque.peekFirst()) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口求最大值"><a href="#滑动窗口求最大值" class="headerlink" title="滑动窗口求最大值"></a>滑动窗口求最大值</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; ++i)&#123;</span><br><span class="line">            myQueue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = myQueue.peek();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            myQueue.poll(nums[i-k]);</span><br><span class="line">            myQueue.offer(nums[i]);</span><br><span class="line">            ans[i-k+<span class="number">1</span>] = myQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>优先队列就是在内部维护一个堆。</p>
<p>堆的典型应用：topK问题，一群数据中求最大的K个数。</p>
<h2 id="Java堆API使用"><a href="#Java堆API使用" class="headerlink" title="Java堆API使用"></a>Java堆API使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小顶堆 </span></span><br><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; myQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">    (o1, o2) -&gt; &#123;<span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a>前k个高频元素</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//1 统计每个元素的出现频率</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            map.put(num, <span class="number">1</span>+map.getOrDefault(num, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2 小顶堆 </span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; myQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            (o1, o2) -&gt; &#123;<span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];&#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(myQueue.size()&lt;k)</span><br><span class="line">                myQueue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue() &gt; myQueue.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                    myQueue.poll();</span><br><span class="line">                    myQueue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; ++i)</span><br><span class="line">            ans[i] = myQueue.poll()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据流中位数"><a href="#数据流中位数" class="headerlink" title="数据流中位数"></a>数据流中位数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/description">https://leetcode.cn/problems/find-median-from-data-stream/description</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; L;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; S;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123; <span class="comment">// [L S] 构成了一个数组 </span></span><br><span class="line">        L = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder()); <span class="comment">// 大顶堆</span></span><br><span class="line">        S = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// 小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// keeping size S &lt;= L &lt;= S+1，即L的大小总是不小于S的大小</span></span><br><span class="line">        <span class="comment">// L peek &lt; S peek</span></span><br><span class="line">        <span class="keyword">if</span>(L.size() == S.size())&#123;</span><br><span class="line">            <span class="comment">// 两个堆数目相等时，L可以再加数，因此将num从S过滤到L</span></span><br><span class="line">            S.add(num);</span><br><span class="line">            L.add(S.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则将num从L过滤到S</span></span><br><span class="line">            L.add(num); </span><br><span class="line">            S.add(L.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.size()&gt;S.size())&#123; <span class="comment">//奇数长度取中间</span></span><br><span class="line">            <span class="keyword">return</span> L.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (L.peek()+S.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意两个堆构成了一个数组，将数组升序排序，[L S] ，L复杂前半部分，S负责后半部分。</p>
<p>为了取中位数，维护大小 S &lt;&#x3D; L &lt;&#x3D; S+1，即L总是大于等于S。</p>
<p>添加数据时，根据L和S的大小情况，选取从S到L，还是从L到S。为什么都需要经过两次堆？因为我们不知道新加的数到底是属于哪个堆。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>栈与队列算法总结</p><p><a href="https://xyz.desirer233.fun/2024/06/03/数据结构与算法/栈与队列/">https://xyz.desirer233.fun/2024/06/03/数据结构与算法/栈与队列/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-06-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-11-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">哈希表算法总结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-item">动态规划</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java中栈的使用"><span class="level-left"><span class="level-item">1</span><span class="level-item">Java中栈的使用</span></span></a></li><li><a class="level is-mobile" href="#栈"><span class="level-left"><span class="level-item">2</span><span class="level-item">栈</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#括号匹配"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">括号匹配</span></span></a></li><li><a class="level is-mobile" href="#比较含退格的字符串"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">比较含退格的字符串</span></span></a></li><li><a class="level is-mobile" href="#字符串去重"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">字符串去重</span></span></a></li><li><a class="level is-mobile" href="#逆波兰式求值"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">逆波兰式求值</span></span></a></li><li><a class="level is-mobile" href="#栈实现队列"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">栈实现队列</span></span></a></li><li><a class="level is-mobile" href="#字符串解码"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">字符串解码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#单调栈"><span class="level-left"><span class="level-item">3</span><span class="level-item">单调栈</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#每日温度"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">每日温度</span></span></a></li><li><a class="level is-mobile" href="#下一个更大元素"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">下一个更大元素</span></span></a></li><li><a class="level is-mobile" href="#下一个更大的元素2"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">下一个更大的元素2</span></span></a></li><li><a class="level is-mobile" href="#接雨水"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">接雨水</span></span></a></li><li><a class="level is-mobile" href="#柱状图最大矩形"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">柱状图最大矩形</span></span></a></li></ul></li><li><a class="level is-mobile" href="#队列"><span class="level-left"><span class="level-item">4</span><span class="level-item">队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#队列实现栈"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">队列实现栈</span></span></a></li></ul></li><li><a class="level is-mobile" href="#单调队列"><span class="level-left"><span class="level-item">5</span><span class="level-item">单调队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理-1"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#滑动窗口求最大值"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">滑动窗口求最大值</span></span></a></li></ul></li><li><a class="level is-mobile" href="#优先队列（堆）"><span class="level-left"><span class="level-item">6</span><span class="level-item">优先队列（堆）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理-2"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#Java堆API使用"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Java堆API使用</span></span></a></li><li><a class="level is-mobile" href="#前k个高频元素"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">前k个高频元素</span></span></a></li><li><a class="level is-mobile" href="#数据流中位数"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">数据流中位数</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cmu15445/"><span class="level-start"><span class="level-item">cmu15445</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/cmu15445/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/buttonRPC/"><span class="level-start"><span class="level-item">buttonRPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/muduo%E7%BD%91%E7%BB%9C%E5%BA%93/"><span class="level-start"><span class="level-item">muduo网络库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/GDB/"><span class="level-start"><span class="level-item">GDB</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/IDE/"><span class="level-start"><span class="level-item">IDE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="level-start"><span class="level-item">命令行</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"><span class="level-start"><span class="level-item">PostgreSQL</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/openGauss/"><span class="level-start"><span class="level-item">openGauss</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/"><span class="level-start"><span class="level-item">计算机工程</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2026 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>