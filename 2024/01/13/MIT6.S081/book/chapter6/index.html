<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MIT6.S081 xv6book chapter6 - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="第六章主要是讲并发编程，为什么要用锁、什么时候使用锁、锁范围、加锁顺序、死锁、可重入锁等知识，还介绍了xv6中自旋锁的实现。 特别要注意xv6中持有锁就不允许中断；内存屏障用于避免指令重排，这些都是锁实现的细节。 本节融合了lec13的内容，总体上属于并发编程入门，信号量、条件变量等多进程同步机制没有介绍，后续章节会涉及。"><meta property="og:type" content="blog"><meta property="og:title" content="MIT6.S081 xv6book chapter6"><meta property="og:url" content="https://xyz.desirer233.fun/2024/01/13/MIT6.S081/book/chapter6/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="第六章主要是讲并发编程，为什么要用锁、什么时候使用锁、锁范围、加锁顺序、死锁、可重入锁等知识，还介绍了xv6中自旋锁的实现。 特别要注意xv6中持有锁就不允许中断；内存屏障用于避免指令重排，这些都是锁实现的细节。 本节融合了lec13的内容，总体上属于并发编程入门，信号量、条件变量等多进程同步机制没有介绍，后续章节会涉及。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xyz.desirer233.fun/img/og_image.png"><meta property="article:published_time" content="2024-01-13T11:00:00.000Z"><meta property="article:modified_time" content="2024-04-22T01:21:43.396Z"><meta property="article:author" content="Desirer"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xyz.desirer233.fun/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2024/01/13/MIT6.S081/book/chapter6/"},"headline":"MIT6.S081 xv6book chapter6","image":["https://xyz.desirer233.fun/img/og_image.png"],"datePublished":"2024-01-13T11:00:00.000Z","dateModified":"2024-04-22T01:21:43.396Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"第六章主要是讲并发编程，为什么要用锁、什么时候使用锁、锁范围、加锁顺序、死锁、可重入锁等知识，还介绍了xv6中自旋锁的实现。 特别要注意xv6中持有锁就不允许中断；内存屏障用于避免指令重排，这些都是锁实现的细节。 本节融合了lec13的内容，总体上属于并发编程入门，信号量、条件变量等多进程同步机制没有介绍，后续章节会涉及。"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2024/01/13/MIT6.S081/book/chapter6/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-13T11:00:00.000Z" title="2024/1/13 19:00:00">2024-01-13</time>发表</span><span class="level-item"><time dateTime="2024-04-22T01:21:43.396Z" title="2024/4/22 09:21:43">2024-04-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MIT6-S081/">MIT6.S081</a><span> / </span><a class="link-muted" href="/categories/MIT6-S081/xv6book/">xv6book</a></span><span class="level-item">23 分钟读完 (大约3482个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MIT6.S081 xv6book chapter6</h1><div class="content"><p>第六章主要是讲并发编程，为什么要用锁、什么时候使用锁、锁范围、加锁顺序、死锁、可重入锁等知识，还介绍了xv6中自旋锁的实现。</p>
<p>特别要注意xv6中持有锁就不允许中断；内存屏障用于避免指令重排，这些都是锁实现的细节。</p>
<p>本节融合了<a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec11-thread-switching-robert">lec13的内容</a>，总体上属于并发编程入门，信号量、条件变量等多进程同步机制没有介绍，后续章节会涉及。</p>
<span id="more"></span>

<h1 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h1><p>A race condition is a situation in which a memory location is accessed concurrently, and at least one access is a write.</p>
<p>锁是如何避免race condition的，这里有两个很好的描述词：序列化、原子化，</p>
<ul>
<li><p>You can think of a lock as <strong>serializing</strong> concurrent critical sections so that they run one at a time, and thus preserve invariants (assuming the critical sections are correct in isolation). </p>
</li>
<li><p>You can also think of critical sections guarded by the same lock as <strong>being atomic</strong> with respect to each other, so that each sees only the complete set of changes from earlier critical sections, and never sees partially-completed updates.</p>
</li>
</ul>
<h1 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h1><p>什么时候使用锁、使用多少个锁：</p>
<p>A hard part about using locks is deciding how many locks to use and which data and invariants each lock should protect. There are a few basic principles. First, any time a variable can be written by one CPU at the same time that another CPU can read or write it, a lock should be used to keep the two operations from overlapping. Second, remember that locks protect invariants: if an invariant involves multiple memory locations, typically all of them need to be protected by a single lock to ensure the invariant is maintained</p>
<p>大内核锁：</p>
<p>A simple kernel can do this on a multiprocessor by having a single lock that must be acquired on entering the kernel and released on exiting the kernel (though system calls such as pipe reads or wait would pose a problem). Many uniprocessor operating systems have been converted to run on multiprocessors using this approach, sometimes called a <strong>“big kernel lock”</strong>, but the approach sacrifices parallelism: only one CPU can execute in the kernel at a time.</p>
<p>如果内核中只有一把大锁，我们暂时将之称为big kernel lock。基本上所有的系统调用都会被这把大锁保护而被序列化。系统调用会按照这样的流程处理：一个系统调用获取到了big kernel lock，完成自己的操作，之后释放这个big kernel lock，再返回到用户空间，之后下一个系统调用才能执行。这样的话，如果我们有一个应用程序并行的调用多个系统调用，这些系统调用会串行的执行，</p>
<h1 id="死锁与锁顺序"><a href="#死锁与锁顺序" class="headerlink" title="死锁与锁顺序"></a>死锁与锁顺序</h1><p>it is important that all code paths acquire those locks in the same order.</p>
<p>获取锁的顺序很重要，如果所有获锁的代码都遵从相同的获锁顺序，那么是不会造成死锁的，但现实中获锁的顺序取决于代码逻辑。</p>
<p>对于一个系统设计者，你需要确定对于所有的锁对象的全局的顺序。例如在这里的例子中我们让d1一直在d2之前，这样我们在rename的时候，总是先获取排序靠前的目录的锁，再获取排序靠后的目录的锁。如果对于所有的锁有了一个全局的排序，这里的死锁就不会出现了。</p>
<p>不过在设计一个操作系统的时候，定义一个全局的锁的顺序会有些问题。如果一个模块m1中方法g调用了另一个模块m2中的方法f，那么m1中的方法g需要知道m2的方法f使用了哪些锁。因为如果m2使用了一些锁，那么m1的方法g必须集合f和g中的锁，并形成一个全局的锁的排序。这意味着在m2中的锁必须对m1可见，这样m1才能以恰当的方法调用m2。</p>
<p>但是这样又违背了代码抽象的原则。在完美的情况下，代码抽象要求m1完全不知道m2是如何实现的。但是不幸的是，具体实现中，m2内部的锁需要泄露给m1，这样m1才能完成全局锁排序。所以当你设计一些更大的系统时，锁使得代码的模块化更加的复杂了。</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>The idea is that if the lock is held by a process and if that process attempts to acquire the lock again, then the kernel could just allow this (since the process already has the lock), instead of calling panic, as the xv6 kernel does</p>
<p>But if re-entrant locks are allowed, and h happens to call g, call_once will be called twice.</p>
<p>If re-entrant locks aren’t allowed, then h calling g results in a deadlock, which is not great either. </p>
<p>可重入锁有优点有缺点，缺点就是它使得并发编程更加复杂了，优点是至少能避免一些死锁的情况。</p>
<h1 id="自旋锁的实现：原子指令"><a href="#自旋锁的实现：原子指令" class="headerlink" title="自旋锁的实现：原子指令"></a>自旋锁的实现：原子指令</h1><p>锁的特性就是只有一个进程可以获取锁，在任何时间点都不能有超过一个锁的持有者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held? 1 is held.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现锁的难点就在于看的动作和写的动作的不连续，中间可能被打断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> <span class="comment">// does not work!</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>) &#123;</span><br><span class="line">      lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>; &#125;</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码并不能实现acquire语义，问题就出在两个进程可以同时进入到判断锁的那一行，此时locked都为0，两个进程会同时将locked设置为1。<strong>这其实是三个操作（读locked、判断locked、写locked）的原子性，如果这三个操作是合在一起的， 便能保证正确性。</strong></p>
<p>解决的方法是依赖于一个特殊的硬件指令，这个特殊的硬件指令会保证一次<strong>test-and-set操作的原子性</strong>，在RISC-V上，这个特殊的指令就是<strong>amoswap（atomic memory swap）原子交换</strong>。</p>
<p>The acquire function wraps the swap in a loop, retrying (spinning) until it has acquired the lock. Each iteration swaps one into lk-&gt;locked and checks the previous value;</p>
<ul>
<li>if the previous value is zero, then we’ve acquired the lock, and the swap will have set lk-&gt;locked to one. </li>
<li>If the previous value is one, then some other CPU holds the lock, and the fact that we atomically swapped one into lk-&gt;locked didn’t change its value.</li>
</ul>
<p>在获取锁时用1去交换，然后判断获取的旧值是否为0，为0说明获得了锁，为1说明此时有其他进程获得了锁，那么交换的1没有改变着之前的值。</p>
<blockquote>
<p>这其实就是保证了锁的唯一性。将1看成苹果，将0看成锁，锁放在桌子上。每个都用苹果换桌子上的东西，如果换到锁，那么说明我拿到锁了，并且这个锁不会再被别人拿到。如果换到苹果，那也只是等价交换，桌子上还是苹果。</p>
</blockquote>
<h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk)) panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  </span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先忽略push_off的作用，可以看到在函数中有一个while循环，这就是刚刚提到的test-and-set循环。实际上C的标准库已经定义了这些原子操作，所以C标准库中已经有一个函数__sync_lock_test_and_set。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)</span><br><span class="line">  800061b4:	87ba                	mv	a5,a4</span><br><span class="line">  800061b6:	0cf4a7af          	amoswap.w.aq	a5,a5,(s1)</span><br><span class="line">  800061ba:	2781                	sext.w	a5,a5</span><br><span class="line">  800061bc:	ffe5                	bnez	a5,800061b4 &lt;acquire+0x22&gt;</span><br></pre></td></tr></table></figure>

<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk)) panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁的过程就是将locked字段原子更新为0的过程。为什么需要原子更新？</p>
<p>因为更新的操作其实有三个步骤：读地址值到寄存器、修改寄存器的值、再将寄存器的值写回到内存。</p>
<h2 id="锁与中断处理程序"><a href="#锁与中断处理程序" class="headerlink" title="锁与中断处理程序"></a>锁与中断处理程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting. push off的嵌套层次</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()? 中断是否开启</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire calls push_off (kernel&#x2F;spinlock.c:89) and release calls pop_off (kernel&#x2F;spinlock.c:100) to <strong>track the nesting level of locks on the current CPU</strong>. When that count reaches zero, pop_off restores the interrupt enable state that existed at the start of the outermost critical section. </p>
<p>第二个细节是，在acquire函数的最开始，会先关闭中断。为什么会是这样呢？先来假设acquire在一开始并没有关闭中断。在uartputc函数中，首先会acquire锁，如果不关闭中断会发生什么呢？uartputc函数会acquire锁，UART本质上就是传输字符，当UART完成了字符传输它会做什么？是的，它会产生一个中断之后会运行uartintr函数，在uartintr函数中，会获取同一把锁，但是这把锁正在被uartputc持有。如果这里只有一个CPU的话，那这里就是死锁。</p>
<p>所以spinlock需要处理两类并发，<strong>一类是不同CPU之间的并发，一类是相同CPU上中断和普通程序之间的并发。</strong></p>
<blockquote>
<p>更深层次的原因是：锁会在各种各样的地方被用到，从用户程序到中断处理程序。而中断又是时时刻刻发生的，如果用户程序持有锁的同时发生中断，中断处理程序又要求获得同一把锁，就会发生死锁。</p>
<p>xv6解决的方法粗暴有效：when a CPU acquires any lock, xv6 always disables interrupts on that CPU. 哪个CPU持有锁就不允许那个CPU处理中断。</p>
</blockquote>
<p><strong>还要注意点的是：</strong></p>
<ul>
<li>关中断在获锁前，开中断在释放锁后；</li>
<li>noff追踪了锁嵌套的层次（track the nesting level of locks on the current CPU），只有最后一个锁释放后才能开中断。</li>
</ul>
<h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>It is natural to think of programs executing in the order in which source code statements appear. Many compilers and CPUs, however, execute code out of order to achieve higher performance.The CPU’s ordering rules are called the memory model.</p>
<p>简单来说，CPU或编译器为了更好的执行性能，通常会调整一些代码的执行顺序。而这会使得锁失效，因为关键区的代码可能会被移到关键区外。</p>
<p>避免指令重排是通过一条硬件指令，内存屏障（memory fence或者叫做synchronize指令）来确定指令的移动范围。对于synchronize指令，任何在它之前的load&#x2F;store指令，都不能移动到它之后。</p>
<p>那么，通过两个内存屏障，加锁时一个，释放锁时一个，就能避免指令乱排带来的后果。</p>
<blockquote>
<p>学生提问：有没有可能在锁acquire之前的一条指令被移到锁release之后？或者说这里会有一个界限不允许这么做？</p>
<p>Frans教授：在这里的例子中，acquire和release都有自己的界限（注，也就是__sync_synchronize函数的调用点）。所以发生在锁acquire之前的指令不会被移到acquire的__sync_synchronize函数调用之后，这是一个界限。在锁的release函数中有另一个界限。所以在第一个界限之前的指令会一直在这个界限之前，在两个界限之间的指令会保持在两个界限之间，在第二个界限之后的指令会保持在第二个界限之后。</p>
<p>学生提问：在一个处理器上运行多个线程与在多个处理器上运行多个进程是否一样？</p>
<p>Frans教授：差不多吧，如果你有多个线程，但是只有一个CPU，那么你还是会想要特定内核代码能够原子执行。所以你还是需要有critical section的概念。你或许不需要锁，但是你还是需要能够对特定的代码打开或者关闭中断。如果你查看一些操作系统的内核代码，通常它们都没有锁的acquire，因为它们假定自己都运行在单个处理器上，但是它们都有开关中断的操作。</p>
</blockquote>
<h1 id="Sleep-locks"><a href="#Sleep-locks" class="headerlink" title="Sleep locks"></a>Sleep locks</h1><p>Holding a spinlock that long would lead to waste if another process wanted to acquire it, since the acquiring process would waste CPU for a long time while spinning.</p>
<p> Another drawback of spinlocks is that a process cannot yield the CPU while retaining a spinlock; we’d like to do this so that other processes can use the CPU while the process with the lock waits for the disk.</p>
<p> Yielding while holding a spinlock is illegal because it might lead to deadlock if a second thread then tried to acquire the spinlock; since acquire doesn’t yield the CPU, the second thread’s spinning might prevent the first thread from running and releasing the lock.</p>
<p> Yielding while holding a lock would also violate the requirement that interrupts must be off while a spinlock is held. <strong>Thus we’d like a type of lock that yields the CPU while waiting to acquire, and allows yields (and interrupts) while the lock is held.</strong></p>
<p>自旋锁的坏处在于尝试获取锁时必须让CPU自旋重试，因此自旋锁不能用于持锁时间长的场景。那么我们会想要这么一种锁：尝试获锁能够让出CPU，而在持有锁时又允许中断，这将会在后来介绍。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>MIT6.S081 xv6book chapter6</p><p><a href="https://xyz.desirer233.fun/2024/01/13/MIT6.S081/book/chapter6/">https://xyz.desirer233.fun/2024/01/13/MIT6.S081/book/chapter6/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-01-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-04-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/01/16/MIT6.S081/book/chapter7/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MIT6.S081 xv6book chapter7</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/01/12/MIT6.S081/lab/lab5/"><span class="level-item">MIT6.S081 lab5 lazy allocation</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#竞态条件"><span class="level-left"><span class="level-item">1</span><span class="level-item">竞态条件</span></span></a></li><li><a class="level is-mobile" href="#锁的使用"><span class="level-left"><span class="level-item">2</span><span class="level-item">锁的使用</span></span></a></li><li><a class="level is-mobile" href="#死锁与锁顺序"><span class="level-left"><span class="level-item">3</span><span class="level-item">死锁与锁顺序</span></span></a></li><li><a class="level is-mobile" href="#可重入锁"><span class="level-left"><span class="level-item">4</span><span class="level-item">可重入锁</span></span></a></li><li><a class="level is-mobile" href="#自旋锁的实现：原子指令"><span class="level-left"><span class="level-item">5</span><span class="level-item">自旋锁的实现：原子指令</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#acquire"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">acquire</span></span></a></li><li><a class="level is-mobile" href="#release"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">release</span></span></a></li><li><a class="level is-mobile" href="#锁与中断处理程序"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">锁与中断处理程序</span></span></a></li><li><a class="level is-mobile" href="#指令重排"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">指令重排</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Sleep-locks"><span class="level-left"><span class="level-item">6</span><span class="level-item">Sleep locks</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/PostgreSQL/"><span class="level-start"><span class="level-item">PostgreSQL</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/cmu15445/"><span class="level-start"><span class="level-item">cmu15445</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/openGauss/"><span class="level-start"><span class="level-item">openGauss</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/GDB/"><span class="level-start"><span class="level-item">GDB</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/IDE/"><span class="level-start"><span class="level-item">IDE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="level-start"><span class="level-item">命令行</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>