<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MIT6.S081 xv6book chapter8 - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这八章讲述了xv6的文件系统，这个文件系统的实现很简单，有许多可以优化的地方，但也有很多复杂的地方。从磁盘组织、缓存、日志、Inode、目录、文件名与文件描述符。其实可以简单分为三部分：  底层存储（磁盘组织、磁盘缓存、Inode、Directory） 持久层（日志事务） 用户层（文件名、文件描述符）  本节融合了lec14和lec15的内容，收获颇丰。"><meta property="og:type" content="blog"><meta property="og:title" content="MIT6.S081 xv6book chapter8"><meta property="og:url" content="https://xyz.desirer233.fun/2024/01/18/MIT6.S081/book/chapter8/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="这八章讲述了xv6的文件系统，这个文件系统的实现很简单，有许多可以优化的地方，但也有很多复杂的地方。从磁盘组织、缓存、日志、Inode、目录、文件名与文件描述符。其实可以简单分为三部分：  底层存储（磁盘组织、磁盘缓存、Inode、Directory） 持久层（日志事务） 用户层（文件名、文件描述符）  本节融合了lec14和lec15的内容，收获颇丰。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xyz.desirer233.fun/Users/mac/Library/Application%20Support/typora-user-images/image-20240118200909901.png"><meta property="og:image" content="https://gitee.com/desirer/backup/raw/master/images/202401182023171.png"><meta property="og:image" content="https://gitee.com/desirer/backup/raw/master/images/202402061548606.png"><meta property="og:image" content="https://gitee.com/desirer/backup/raw/master/images/202401191721465.png"><meta property="og:image" content="https://gitee.com/desirer/backup/raw/master/images/202401191724182.png"><meta property="og:image" content="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MSpMagokZL7AbkiMl0E%2F-MSqLOpt08W4Q2llf3SA%2Fimage.png?alt=media&amp;token=583cfcf5-3f40-4777-817a-3bf98aeee785"><meta property="article:published_time" content="2024-01-18T11:00:00.000Z"><meta property="article:modified_time" content="2026-02-21T07:11:50.495Z"><meta property="article:author" content="Desirer"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xyz.desirer233.fun/Users/mac/Library/Application%20Support/typora-user-images/image-20240118200909901.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2024/01/18/MIT6.S081/book/chapter8/"},"headline":"MIT6.S081 xv6book chapter8","image":["https://xyz.desirer233.fun/Users/mac/Library/Application%20Support/typora-user-images/image-20240118200909901.png","https://gitee.com/desirer/backup/raw/master/images/202401182023171.png","https://gitee.com/desirer/backup/raw/master/images/202402061548606.png","https://gitee.com/desirer/backup/raw/master/images/202401191721465.png","https://gitee.com/desirer/backup/raw/master/images/202401191724182.png"],"datePublished":"2024-01-18T11:00:00.000Z","dateModified":"2026-02-21T07:11:50.495Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"这八章讲述了xv6的文件系统，这个文件系统的实现很简单，有许多可以优化的地方，但也有很多复杂的地方。从磁盘组织、缓存、日志、Inode、目录、文件名与文件描述符。其实可以简单分为三部分：  底层存储（磁盘组织、磁盘缓存、Inode、Directory） 持久层（日志事务） 用户层（文件名、文件描述符）  本节融合了lec14和lec15的内容，收获颇丰。"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2024/01/18/MIT6.S081/book/chapter8/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-18T11:00:00.000Z" title="2024/1/18 19:00:00">2024-01-18</time>发表</span><span class="level-item"><time dateTime="2026-02-21T07:11:50.495Z" title="2026/2/21 15:11:50">2026-02-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MIT6-S081/">MIT6.S081</a><span> / </span><a class="link-muted" href="/categories/MIT6-S081/xv6book/">xv6book</a></span><span class="level-item">43 分钟读完 (大约6511个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MIT6.S081 xv6book chapter8</h1><div class="content"><p>这八章讲述了xv6的文件系统，这个文件系统的实现很简单，有许多可以优化的地方，但也有很多复杂的地方。从磁盘组织、缓存、日志、Inode、目录、文件名与文件描述符。其实可以简单分为三部分：</p>
<ul>
<li>底层存储（磁盘组织、磁盘缓存、Inode、Directory）</li>
<li>持久层（日志事务）</li>
<li>用户层（文件名、文件描述符）</li>
</ul>
<p>本节融合了<a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec14-file-systems-frans">lec14</a>和<a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec15-crash-recovery-frans">lec15</a>的内容，收获颇丰。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文件系统的有趣性：</p>
<ul>
<li>抽象：如何对硬件的抽象</li>
<li>崩溃恢复——文件系统的持久性</li>
<li>文件组织——如何在磁盘上排布文件系统</li>
<li>性能——读取磁盘通常比较慢，如何取得性能的提升</li>
</ul>
<p>文件系统分层：</p>
<img src="/Users/mac/Library/Application Support/typora-user-images/image-20240118200909901.png" alt="image-20240118200909901" style="zoom:80%;" />

<ul>
<li><p>最底层是磁盘，也就是一些实际保存数据的存储设备，正是这些设备提供了持久化存储。</p>
</li>
<li><p>在这之上是buffer cache或者说block cache，这些cache可以避免频繁的读写磁盘。这里我们将磁盘中的数据保存在了内存中。</p>
</li>
<li><p>为了保证持久性，再往上通常会有一个logging层。</p>
<p>longging层之上有inode cache，这主要是为了同步（synchronization）。</p>
</li>
<li><p>再往上就是inode本身了。它实现了read&#x2F;write。</p>
</li>
<li><p>再往上，就是文件名，和文件描述符操作。</p>
</li>
</ul>
<p>文件究竟维护了怎样的数据结构呢？<strong>核心的数据结构就是inode和file descriptor。</strong>后者主要与用户进程进行交互。</p>
<p><strong>最重要的就是Inode，它代表了一个文件。</strong>文件名只是一个link，Inode之间通过编号进行区分。</p>
<ul>
<li>inode必须有一个link count来跟踪指向这个inode的文件名的数量。一个文件（inode）只能在link count为0的时候被删除。</li>
<li>实际中还有一个openfd count，也就是当前打开了文件的文件描述符计数。一个文件只能在这两个计数器都为0的时候才能被删除。</li>
<li>文件描述符必然自己悄悄维护了对于文件的offset。</li>
</ul>
<h1 id="磁盘组织"><a href="#磁盘组织" class="headerlink" title="磁盘组织"></a>磁盘组织</h1><p><strong>屏蔽不同磁盘的区别，我们可以将磁盘看成block或setor的数组，每个block大小固定，这样我们就能通过块号读取一个块的内容。</strong></p>
<p><img src="https://gitee.com/desirer/backup/raw/master/images/202401182023171.png"></p>
<ul>
<li><p>block0要么没有用，要么被用作boot sector来启动操作系统。</p>
</li>
<li><p>block1通常被称为super block，它描述了文件系统。它可能包含磁盘上有多少个block共同构成了文件系统这样的信息。</p>
</li>
<li><p>在XV6中，log从block2开始，到block32结束。实际上log的大小可能不同，这里在super block中会定义log就是30个block。</p>
</li>
<li><p>接下来在block32到block45之间，XV6存储了inode。我之前说过多个inode会打包存在一个block中，一个inode是64字节。</p>
</li>
<li><p>之后是bitmap block，这是我们构建文件系统的默认方法，它只占据一个block。它记录了数据block是否空闲。</p>
</li>
<li><p>之后就全是数据block了，数据block存储了文件的内容和目录的内容。</p>
</li>
</ul>
<h2 id="On-disk-inode-structure"><a href="#On-disk-inode-structure" class="headerlink" title="On-disk inode structure"></a>On-disk inode structure</h2><p><strong>Inode代表一个文件，那Inode究竟是怎么组织的呢？</strong></p>
<p>Inode有两种形式，一种是在磁盘上，一种是在内存上。稍后将会解释为什么会有两种Inode模型，以及这两种Inode之间的同步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type， files, directories, and special files (devices) or zero</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses #define NDIRECT 12</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>The <code>type</code> field distinguishes between files, directories, and special files (devices). A type of zero indicates that an on- disk inode is free. </li>
<li>The <code>nlink</code> field counts the number of directory entries that refer to this inode, in order to recognize when the on-disk inode and its data blocks should be freed. </li>
<li>The <code>addrs</code> array records the block numbers of the disk blocks holding the file’s content.The last entry in the <code>addrs</code> array gives the address of the indirect block.</li>
</ul>
<img src="https://gitee.com/desirer/backup/raw/master/images/202402061548606.png" style="zoom:80%;" />

<p>dinode 最令人不解的通常就是addrs数组了，它其实类似多级页表。首先，addrs数组存储了所有文件内容所在块的块号。它分为两级索引，第一级索引是直接映射，意思是我得到的块号就是文件内容真实的块号。第二级索引是addrs[12]的内容，它得到块号指向一个数据块，这个数据块才真正指向了文件内容块号。所以在xv6中，文件大小最多是 （12 + 256）* block size 这么大。</p>
<p>当dinode的type字段为T_DIR时，表明这个dinode是目录。目录的数据内容存的是目录条目，包含2字节的inode编号和14字节的文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum; </span><br><span class="line">  <span class="type">char</span> name[DIRSIZ]; <span class="comment">// #define DIRSIZ 14</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看完On-disk inode structure我们就知道了，文件内容是放在data区，Inode用来索引这些文件，并区分文件类型。这是通常的设计，<strong>文件的元信息和文件内容分离存储。</strong></p>
<h2 id="in-memory-copy-of-an-inode"><a href="#in-memory-copy-of-an-inode" class="headerlink" title="in-memory copy of an inode"></a>in-memory copy of an inode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count 指向inode的指针个数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;  <span class="comment">//指向inode的目录项个数</span></span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct inode is the <strong>in-memory copy of a struct dinode on disk</strong>. The kernel stores an inode in memory only if there are C pointers referring to that inode</p>
<p>为什么会有in-memory copy of an inode 的存在？其实就是方便操作系统管理inode，提供更多关于inode的信息，比如引用计数等。</p>
<h1 id="Buffer-Cache"><a href="#Buffer-Cache" class="headerlink" title="Buffer Cache"></a>Buffer Cache</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>创建文件的过程其实就是<strong>创建inode</strong>，然后写inode的内容，最后同步到磁盘。通过inode代表文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an inode on device dev.</span></span><br><span class="line"><span class="comment">// Mark it as allocated by giving it type.</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode.</span></span><br><span class="line"><span class="keyword">struct</span> inode* <span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span> &#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123; <span class="comment">// sb == super block</span></span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb)); <span class="comment">// 读取缓存</span></span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB; <span class="comment">// 地址+偏移</span></span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;ialloc: no inodes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>superblock记录了inode的数量，遍历所有创建好的inode，然后查看是否是空闲的inode（其type字段为0），然后使用它。</p>
<p>重点看这两行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bp = bread(dev, IBLOCK(inum, sb)); </span><br><span class="line">dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inodes per block.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span></span><br><span class="line"><span class="comment">// Block containing inode i</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span></span><br></pre></td></tr></table></figure>

<p>通过bread函数，我们读取了特定设备dev上的第<code>IBLOCK(inum, sb)</code>个block的内容到buf上。通过宏定义我们能够知道<code>IBLOCK(inum, sb)</code>就是第<code>inum</code> 个 <code>inode</code>所在的块号，<code>inum%IPB</code>则是inode在块内的偏移量。</p>
<p>bread函数将读取磁盘的过程作了一层封装，我们再看bread函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="keyword">struct</span> buf* <span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123; <span class="comment">// 如果没在cache中找到，就读取磁盘</span></span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到bread其实是先调用bget</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf* <span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++; <span class="comment">// 增加引用计数</span></span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b; <span class="comment">// returns the locked buffer</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached. 回收一个buf</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bget读取的是bcache（缓存），如果缓存中没有，返回一个加锁的buf（containing a copy of a block which can be read or modified in memory)，如果buf失效，最后才从磁盘读。</p>
<h2 id="bcache"><a href="#bcache" class="headerlink" title="bcache"></a>bcache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span> <span class="comment">// 30</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache; </span><br></pre></td></tr></table></figure>

<p>bcache就是个大小为30的LRU链表，链表的元素为buf。buf具有引用计数，表明有多少个线程正在使用它。blockno块号的内容就存在data里。</p>
<p>The buffer cache has two jobs: (1) synchronize access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; (2) cache popular blocks so that they don’t need to be re-read from the slow disk. </p>
<p>buffer cache作为缓存能有效的减少访问磁盘的时间，同时buffer cache必须保证一个磁盘block之对应一个buf，一个buf只能被一个线程使用，否则就会出问题。</p>
<blockquote>
<p>如果buffer cache中有两份block 33的cache将会出现问题。假设一个进程要更新inode19，另一个进程要更新inode20。如果它们都在处理block 33的cache，并且cache有两份，那么第一个进程可能持有一份cache并先将inode19写回到磁盘中，而另一个进程持有另一份cache会将inode20写回到磁盘中，并将inode19的更新覆盖掉。所以一个block只能在buffer cache中出现一次。</p>
</blockquote>
<blockquote>
<p>从bget返回加锁的buf这点来看，xv6并不支持多个线程同时读写一块block。第二个获取相同block的线程需要等待第一个线程释放，acquiresleep确保线程能够睡眠。</p>
</blockquote>
<h1 id="Logging-Layer"><a href="#Logging-Layer" class="headerlink" title="Logging Layer"></a>Logging Layer</h1><p>logging的目标：实现原子的系统调用，快速恢复和高性能。</p>
<h2 id="持久化的基本思想"><a href="#持久化的基本思想" class="headerlink" title="持久化的基本思想"></a>持久化的基本思想</h2><p>xv6 系统调用不直接写入磁盘上的文件系统数据结构。相反，它会在磁盘上的日志中放置它希望进行的所有磁盘写入的描述。一旦系统调用记录了其所有写入操作，它就会将一条特殊的提交记录写入磁盘，指示该日志包含完整的操作。此时，系统调用将写入复制到磁盘文件系统数据结构中。完成这些写入后，系统调用将擦除磁盘上的日志。</p>
<p><img src="https://gitee.com/desirer/backup/raw/master/images/202401191721465.png">简单来说：就是系统调用先写log区，log区写完后写一条提交记录。提交记录写完，再将log区的block搬回到data区，搬运完之后擦除磁盘的日志。</p>
<p>遵循write ahead rule，也就是说在写入commit记录之前，你需要确保所有的写操作都在log中。</p>
<h2 id="日志设计"><a href="#日志设计" class="headerlink" title="日志设计"></a>日志设计</h2><p><img src="https://gitee.com/desirer/backup/raw/master/images/202401191724182.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n; <span class="comment">//  log blocks</span></span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;       <span class="comment">// log信息在磁盘上的位置（开始的block块的索引号)</span></span><br><span class="line">  <span class="type">int</span> size;        <span class="comment">// log区的总的block块的数目。</span></span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// 当前正在使用LOG机制的文件系统调用数目(目的是别超过了LOG系统总容量)</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// 当前是不是正处于LOG的提交中,也就是正在写LOG进入磁盘呢</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span>  <span class="comment">// 磁盘logheader在内存中的一份映射</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<p>log主要由两部分组成，log header和log block。header里有一个数组追踪每个log block。</p>
<h2 id="日志基本调用流程"><a href="#日志基本调用流程" class="headerlink" title="日志基本调用流程"></a>日志基本调用流程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op(); <span class="comment">// 第一步</span></span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp); <span class="comment">// 中间步骤，记录写的buf块</span></span><br><span class="line">...</span><br><span class="line">end_op(); <span class="comment">//最后一部</span></span><br></pre></td></tr></table></figure>

<p>begin_op表示开启一次日志记录，这里暂时不揭示内容。</p>
<p>bread读缓存然后对data进行修改，此时需要调用log_write来记录修改到log。让我们来看看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Caller has modified b-&gt;data and is done with the buffer.</span></span><br><span class="line"><span class="comment">// Record the block number and pin in the cache by increasing refcnt.</span></span><br><span class="line"><span class="comment">// commit()/write_log() will do the disk write.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorption</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b); </span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在内存中修改了一个磁盘数据后，如果想从缓存真正写入的磁盘上， 有<code>bwirte()</code>函数。但是，xv6支持了log机制，使用<code>log_write()</code>代替了<code>bwrite()</code>函数来完成这个工作。 该函数其实只完成：<strong>在logheader中记录要写入的block块。</strong>(如果已经记录过，就无需再次添加，称之为log absorbtion)。这里注意，还调用<code>bpin</code>让这个buf的引用计数增一，避免这个脏块在回写前被<code>bget</code>给回收掉。</p>
<p>真正的写磁盘的动作在<code>end_op()</code>函数中来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码最前端有一些复杂情况处理，直接跳过，看commit函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">commit</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_log</span><span class="params">(<span class="type">int</span> dev)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>[dev].lh.n; tail++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(dev, <span class="built_in">log</span>[dev].start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(dev, <span class="built_in">log</span>[dev].lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">        memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">        bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">        brelse(from);</span><br><span class="line">        brelse(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_head</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(dev, <span class="built_in">log</span>[dev].start);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    hb-&gt;n = <span class="built_in">log</span>[dev].lh.n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>[dev].lh.n; i++) &#123;</span><br><span class="line">        hb-&gt;block[i] = <span class="built_in">log</span>[dev].lh.block[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bwrite(buf);</span><br><span class="line">    brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>write_log</code>将缓冲块写入到磁盘的<strong>日志区</strong>，完成脏块的持久化。</p>
<p><code>write_head</code>则将logheader进行持久化。</p>
<p><code>install_trans</code>负责<strong>使用日志覆盖掉对应的盘块</strong>。该方法读取<code>logheader.blocks</code>数组，将每个对应的日志区的盘块安装到文件区。</p>
<p>当成功用日志覆盖掉对应的盘块后，系统已经无需再继续持有这些日志，因此会再次调用<code>write_head</code>修改日志区的<code>logheader</code>来清除日志，并设定<code>log[dev].lh.n</code> &#x3D; 0。</p>
<h2 id="日志挑战"><a href="#日志挑战" class="headerlink" title="日志挑战"></a>日志挑战</h2><p>第一个挑战是bcache不能撤回已经在日志transaction中的buf，这么做会破坏原子性。所以有一个buf_pin操作会将buf固定在cache中（实际上就是增加一个引用计数）</p>
<p>第二个挑战是文件系统操作受限于log大小。这里意思是说xv6的log区大小为30，这就限制一次系统调用最多写的block数量。如果写入的block数超过了30，那么一个写操作会被分割成多个小一些的写操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">  <span class="type">int</span> n1 = n - i;</span><br><span class="line">  <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">    n1 = max;</span><br></pre></td></tr></table></figure>

<p>第三个挑战就是并发操作。</p>
<p>log的并发还挺有意思的，除了加锁保护外，还限制于log的空间大小。</p>
<p>比如，现在有两个并发的transaction，其中t0在log的前半部分，t1在log的后半部分，可是用完了log空间但一个transcation都没完成。这样就陷入了死锁，任何一个transaction 都期待另一个提交释放空间，但一个都不能提交。</p>
<p> <img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MSpMagokZL7AbkiMl0E%2F-MSqLOpt08W4Q2llf3SA%2Fimage.png?alt=media&token=583cfcf5-3f40-4777-817a-3bf98aeee785"></p>
<p><strong>所以说还要保证多个并发transaction也适配log的大小。</strong>当我们还没有完成一个文件系统操作时，我们必须在确保可能写入的总的log数小于log区域的大小的前提下，才允许另一个文件系统操作开始。</p>
<p>XV6通过限制并发文件系统操作的个数来实现这一点。在begin_op中，我们会检查当前有多少个文件系统操作正在进行。如果有太多正在进行的文件系统操作，我们会通过sleep停止当前文件系统操作的运行，并等待所有其他所有的文件系统操作都执行完并commit之后再唤醒。这里的其他所有文件系统操作都会一起commit。有的时候这被称为group commit，因为这里将多个操作像一个大的transaction一样提交了，这里的多个操作要么全部发生了，要么全部没有发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the start of each FS system call.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，如果log正在commit过程中，那么就等到log提交完成，因为我们不能在install log的过程中写log；<strong>其次，如果当前操作是允许并发的操作个数的后一个，那么当前操作可能会超过log区域的大小，我们也需要sleep并等待所有之前的操作结束；</strong>最后，如果当前操作可以继续执行，需要将log的outstanding字段加1，最后再退出函数并执行文件系统操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再看end_op的前半部分。在最开始首先会对log的outstanding字段减1，因为一个transaction正在结束；其次检查committing状态，当前不可能在committing状态，所以如果是的话会触发panic；如果当前操作是整个并发操作的最后一个的话（log.outstanding &#x3D;&#x3D; 0），接下来立刻就会执行commit；如果当前操作不是整个并发操作的最后一个的话，我们需要唤醒在begin_op中sleep的操作，让它们检查是不是能运行。</p>
<p>所以，即使是XV6中这样一个简单的文件系统，也有一些复杂性和挑战。</p>
<h2 id="崩溃恢复过程"><a href="#崩溃恢复过程" class="headerlink" title="崩溃恢复过程"></a>崩溃恢复过程</h2><p>崩溃恢复的过程也很简单，只需要读log里未提交的日志就行。那什么是真正的提交节点呢？在commit函数中已经指示了，write head就是那么一个节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">commit</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write_head将n不为0的head写入log区。下次开机启动时，扫描log区的head，查看其n字段是否为0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  read_head();</span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Path-name-命名空间"><a href="#Path-name-命名空间" class="headerlink" title="Path name 命名空间"></a>Path name 命名空间</h1><p>我们知道，inode代表文件，但是为了便于使用，我们还管理一个命令空间。命名空间是以”&#x2F;“为起点的树，每个目录下有”.”代表自身，有”..”代表上一级目录。怎么实现呢？</p>
<p>一般来说，根目录是固定在磁盘上某个块上的，比如1号块。遍历路径逻辑就是从根目录开始读取目录条目，然后逐个查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  ip = iget(ROOTDEV, ROOTINO);</span><br></pre></td></tr></table></figure>

<p>xv6没有对目录查找进行优化，只是简单的线性查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;<span class="comment">// skiplem相当于将path分为两部分，name是前一个部分，path是后一部分</span></span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip); <span class="comment">// avoid 死锁</span></span><br><span class="line">    ip = next;  <span class="comment">// 通过name目录找到当前的path</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h1><p>Unix 界面的一个很酷的方面是 Unix 中的大多数资源都表示为文件，包括控制台、管道等设备，当然还有真实文件。文件描述符层是实现这种通用性的层。</p>
<p><strong>具体来说，就是用一个file结构体来包裹文件、管道、设备。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span> <span class="comment">//万物皆文件，就是这里了</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE, io offset</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进程有一个打开文件的数组，数组下标就是文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们使用文件描述符进行读写时，实际上是通过文件描述符作为索引得到file结构体，再通过file结构体进行相应type的读写。</p>
<h2 id="ftable"><a href="#ftable" class="headerlink" title="ftable"></a>ftable</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="keyword">struct</span> file*    <span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file*)</span>;</span><br><span class="line"><span class="keyword">struct</span> file*    <span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file*)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">fileinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file*, uint64, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file*, uint64 addr)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file*, uint64, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>xv6对于file结构体的使用，也采用了一个池化的思想。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file* <span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们看看打开文件的过程：open系统调用，如果传入的是 O_CREATE 标志，说明要新创建文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则就通过name打开相应的inode</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f) <span class="comment">// 这里可能分配的file结构体，所以还需要释放它</span></span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看create函数，其实就是找到父级目录，然后分配inode结构体，增加目录项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//creates a new name for a new inode</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="comment">// find path‘s parent，return inode</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line"> <span class="comment">// look in directory first，file类型在dp中找到name是合理的</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123; <span class="comment">// Look for a directory entry in a directory.</span></span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// then create it</span></span><br><span class="line">  <span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: ialloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;major = major;</span><br><span class="line">  ip-&gt;minor = minor;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries.</span></span><br><span class="line">    dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line">    iupdate(dp);</span><br><span class="line">    <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line">    <span class="keyword">if</span>(dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;create dots&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到sys_open，这里才是分配fd的地方：先分配file结构体，然后分配fd文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br></pre></td></tr></table></figure>

<p>分配文件描述符的过程就是遍历文件的openfiletable，找到未使用的下标。这样我们就能理解一个进程打开的文件描述符是有限的这句话。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file descriptor for the given file.</span></span><br><span class="line"><span class="comment">// Takes over file reference from caller on success.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span>&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc(); <span class="comment">// 遍历进程的open file table，find an unused slot</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;ofile[fd] = f;</span><br><span class="line">      <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这一章的学习，xv6的架构基本已经完成。我们学习了文件块在磁盘上的组织，读取磁盘块时的LRU缓存，为文件系统操作系统持久化的日志块，为用户提供友好的命名空间以及文件描述符，这都是unix很精髓的一部分。</p>
<p>文件系统的学习，主要有以下几个思想吧：</p>
<ul>
<li>文件系统的设计（磁盘块具体存储分布、Inode文件、file统一文件）</li>
<li>缓存池化思想（bcache、itable、ftable）</li>
<li>日志持久化思想（transaction）</li>
</ul>
<p>当然，文件系统还需应对并发处理，这里讲得内容很少。其中一个点是磁盘读取时用了sleeplock而不是spinlock，这是因为磁盘读取通常是一个持续时间较长的操作。更多关于加锁控制，比如ilock加锁，namex不加锁等等有具体的原因，这点也需要继续深入。</p>
<p>同时xv6的很多实现都可以继续优化，比如目录项查找以及日志性能等。这些下一章会讲。</p>
<blockquote>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/KatyuMarisaBlog/p/14385792.html">https://www.cnblogs.com/KatyuMarisaBlog/p/14385792.html</a></p>
</blockquote>
</div><div class="article-licensing box"><div class="licensing-title"><p>MIT6.S081 xv6book chapter8</p><p><a href="https://xyz.desirer233.fun/2024/01/18/MIT6.S081/book/chapter8/">https://xyz.desirer233.fun/2024/01/18/MIT6.S081/book/chapter8/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-01-18</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2026-02-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/01/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/csapp%E7%AC%AC7%E7%AB%A0%E9%93%BE%E6%8E%A5/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">CSAPP第7章 链接</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/01/18/MIT6.S081/lab/lab9/"><span class="level-item">MIT6.S081 lab9 locks</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#磁盘组织"><span class="level-left"><span class="level-item">2</span><span class="level-item">磁盘组织</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#On-disk-inode-structure"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">On-disk inode structure</span></span></a></li><li><a class="level is-mobile" href="#in-memory-copy-of-an-inode"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">in-memory copy of an inode</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Buffer-Cache"><span class="level-left"><span class="level-item">3</span><span class="level-item">Buffer Cache</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#文件"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">文件</span></span></a></li><li><a class="level is-mobile" href="#bcache"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">bcache</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Logging-Layer"><span class="level-left"><span class="level-item">4</span><span class="level-item">Logging Layer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#持久化的基本思想"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">持久化的基本思想</span></span></a></li><li><a class="level is-mobile" href="#日志设计"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">日志设计</span></span></a></li><li><a class="level is-mobile" href="#日志基本调用流程"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">日志基本调用流程</span></span></a></li><li><a class="level is-mobile" href="#日志挑战"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">日志挑战</span></span></a></li><li><a class="level is-mobile" href="#崩溃恢复过程"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">崩溃恢复过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Path-name-命名空间"><span class="level-left"><span class="level-item">5</span><span class="level-item">Path name 命名空间</span></span></a></li><li><a class="level is-mobile" href="#File-descriptor-layer"><span class="level-left"><span class="level-item">6</span><span class="level-item">File descriptor layer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ftable"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">ftable</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">7</span><span class="level-item">总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cmu15445/"><span class="level-start"><span class="level-item">cmu15445</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/cmu15445/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/buttonRPC/"><span class="level-start"><span class="level-item">buttonRPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/muduo%E7%BD%91%E7%BB%9C%E5%BA%93/"><span class="level-start"><span class="level-item">muduo网络库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/GDB/"><span class="level-start"><span class="level-item">GDB</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/IDE/"><span class="level-start"><span class="level-item">IDE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="level-start"><span class="level-item">命令行</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"><span class="level-start"><span class="level-item">PostgreSQL</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/openGauss/"><span class="level-start"><span class="level-item">openGauss</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/"><span class="level-start"><span class="level-item">计算机工程</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2026 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>