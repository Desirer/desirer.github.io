<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Effective C++ 读书笔记2 - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="effective cpp读书笔记第二部分，面向对象、模版等。"><meta property="og:type" content="blog"><meta property="og:title" content="Effective C++ 读书笔记2"><meta property="og:url" content="https://xyz.desirer233.fun/2025/06/15/C++/effecitve%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="effective cpp读书笔记第二部分，面向对象、模版等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xyz.desirer233.fun/img/og_image.png"><meta property="article:published_time" content="2025-06-15T02:00:00.000Z"><meta property="article:modified_time" content="2025-07-20T03:03:55.000Z"><meta property="article:author" content="Desirer"><meta property="article:tag" content="读书笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xyz.desirer233.fun/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2025/06/15/C++/effecitve%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/"},"headline":"Effective C++ 读书笔记2","image":["https://xyz.desirer233.fun/img/og_image.png"],"datePublished":"2025-06-15T02:00:00.000Z","dateModified":"2025-07-20T03:03:55.000Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"effective cpp读书笔记第二部分，面向对象、模版等。"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2025/06/15/C++/effecitve%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-15T02:00:00.000Z" title="2025/6/15 10:00:00">2025-06-15</time>发表</span><span class="level-item"><time dateTime="2025-07-20T03:03:55.000Z" title="2025/7/20 11:03:55">2025-07-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">19 分钟读完 (大约2878个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Effective C++ 读书笔记2</h1><div class="content"><p>effective cpp读书笔记第二部分，面向对象、模版等。</p>
<span id="more"></span>

<h1 id="29-为异常安全努力是值得的"><a href="#29-为异常安全努力是值得的" class="headerlink" title="29 为异常安全努力是值得的"></a>29 为异常安全努力是值得的</h1><p>异常安全函数提供以下三个基本保证之一：</p>
<ul>
<li>一致性：如果异常被抛出，所有对象都处于一种内部前后一致的状态。</li>
<li>原子性：如果函数成功，就是完全成功；如果函数失败，程序回复到“调用函数之前”的状态。</li>
<li>nothrow保证：承诺不抛出异常。</li>
</ul>
<p>我们该为我们写的函数提供哪种保证？往往想提供最强烈保证（原子性）。</p>
<h2 id="copy-and-swap策略"><a href="#copy-and-swap策略" class="headerlink" title="copy and swap策略"></a>copy and swap策略</h2><p>简单实用的策略：当你打算修改一个对象时，先拷贝一份它的副本，然后在它的副本上应用修改，最后将对象与副本交换。</p>
<p>这个策略的好处是：当你的修改发生异常时，任何改动都不会影响原来的对象。</p>
<p>但是copy and swap策略并不能保证整个函数有强烈的异常安全性，考虑以下采用了该策略的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void someFunc()</span><br><span class="line">&#123;</span><br><span class="line">	... // 拷贝副本 </span><br><span class="line">	f1();</span><br><span class="line">	f2();</span><br><span class="line">	... // 置换副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管f1与f2都提供了强烈的异常安全保证，但是如果f1完成任务，f2中途抛出异常，并回退到f2调用前的状态，问题是程序的状态已经被改变（f1所为）。</p>
<p>如果系统内有一个函数不具备异常安全性，整个系统就不具备异常安全性，因为调用那个异常不安全的函数就有可能导致资源泄漏或数据结构败坏。</p>
<h1 id="30-了解inline的里里外外"><a href="#30-了解inline的里里外外" class="headerlink" title="30 了解inline的里里外外"></a>30 了解inline的里里外外</h1><p>（1）inline只是对编译器的一个申请，并不是强制命令。</p>
<p>（2）class内定义的函数，往往是隐式inline。</p>
<p>（3）inline造成的代码膨胀，可能导致额外的换页行为，降低指令高速缓存装置的命中率。</p>
<p>（4）virtrual与inline是冲突的</p>
<p>inline意味着在编译期，将函数的调用动作替换为函数的本体；virtual则意味着“等待，在运行期间决定调用哪个函数”。</p>
<p>（5）构造函数、析构函数与inline配合也是糟糕的</p>
<p>原因在于编译器为空白的构造函数添加了许多成员默认初始化语句，这将显著增大代码体积。</p>
<p>（6）inline函数无法随着程序库的升级而升级</p>
<p>如果f是程序库中的一个inline函数，一旦设计者决定改变f，所有用到f的客户端程序都需要重新编译；如果f是非inline函数，客户端只需要重新链接。</p>
<h1 id="31-将文件间的编译依存关系降至最低"><a href="#31-将文件间的编译依存关系降至最低" class="headerlink" title="31 将文件间的编译依存关系降至最低"></a>31 将文件间的编译依存关系降至最低</h1><h2 id="编译依存关系"><a href="#编译依存关系" class="headerlink" title="编译依存关系"></a>编译依存关系</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;data.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string theName; <span class="comment">// 实现细目</span></span><br><span class="line">	Date theBirthDay;  	<span class="comment">// 实现细目</span></span><br><span class="line">	Address theAddress; <span class="comment">// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++并没有将“接口与实现分离”这件事情做得很好，Class的定义式不仅包含了class的接口，还包括了十足的实现细节。如此，Person定义文件便与其含入的文件之间形成了编译依存关系：</p>
<p><strong>如果Person依赖的任何一个头文件改变，那么每一个含入Person Class的文件都需要重新编译。</strong></p>
<h2 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h2><p>既然依赖的头文件改变会影响我们，那么将头文件去除，改为前向声明如何？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">string</span>; <span class="comment">//前向声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">//前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">//前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string theName; <span class="comment">// 实现细目</span></span><br><span class="line">	Date theBirthDay;  	<span class="comment">// 实现细目</span></span><br><span class="line">	Address theAddress; <span class="comment">// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这并不能通过编译：编译器无法在编译期间知道类对象的大小（除非拿到实现细节）。</p>
<h2 id="PImpl"><a href="#PImpl" class="headerlink" title="PImpl"></a>PImpl</h2><p>虽然编译器不知道类对象的大小，但是指针大小是固定的，于是可以这么玩：将Person分割为两个class，一个只提供接口，一个负责实现接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// 标准库不该被前置声明</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">//前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">//前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;PersonImpl&gt; pImpl; <span class="comment">// 指向实现的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>像Person这样使用pimpl idiom的classes，被称为Handle classes。它不完成工作，只负责将工作转交给实现类。</p>
<p>优点：</p>
<ul>
<li><strong>二进制兼容</strong>（ABI stability）。当 TableBuilder 类库更新时，只要其接口(.h 文件)保持不变，即使实现中 Rep 结构体增加成员，或者更改接口的实现，依赖该库的应用程序<strong>只用更新动态库文件，无需重新编译</strong>。</li>
<li><strong>少编译依赖</strong>。如果 Rep 结构体的定义在头文件中，那么任何对 Rep 结构体的修改都会导致包含了 table_builder.h 的文件重新编译。</li>
<li><strong>接口与实现分离</strong>。接口（在 .h 文件中定义的公共方法）和实现（在 .cc 文件中定义的 Rep 结构体以及具体实现）是完全分开的。这使得在不更改公共接口的情况下，开发者可以自由地修改实现细节，如添加新的私有成员变量或修改内部逻辑。</li>
</ul>
<p>缺点：</p>
<ul>
<li>生命周期管理开销（Runtime Overhead）: Pimpl 通常需要在堆上动态分配内存来存储实现对象（Impl 对象）。这种动态分配比<strong>在栈上分配对象（通常是更快的分配方式）慢</strong>，且涉及到更复杂的内存管理。此外，堆上分配内存，如果没有释放会造成内存泄露。不过就上面例子来说，Rep 在对象构造时分配，并在析构时释放，不会造成内存泄露。</li>
<li><strong>访问开销（Access Overhead）</strong>: 每次通过 Pimpl 访问私有成员函数或变量时，都需要通过指针间接访问。</li>
<li><strong>空间开销（Space Overhead）</strong>: 每个使用 Pimpl 的类都会在其对象中增加至少一个指针的空间开销来存储实现的指针。如果实现部分需要访问公共成员，可能还需要额外的指针或者通过参数传递指针</li>
</ul>
<p>缺点：它使你在运行期间丧失若干速度，有让你为每个对象付出超额内存。</p>
<blockquote>
<p>时间、空间双损 :sweat_smile:</p>
</blockquote>
<h1 id="32-确定你的public继承塑模出is-a关系"><a href="#32-确定你的public继承塑模出is-a关系" class="headerlink" title="32 确定你的public继承塑模出is-a关系"></a>32 确定你的public继承塑模出is-a关系</h1><p>“public继承”意味着“是一个”，任何一个适用于base class的事情也一定适用于derived classs上，每一个derived class对象也都是一个base class对象。</p>
<h1 id="33-避免遮掩继承而来的名称"><a href="#33-避免遮掩继承而来的名称" class="headerlink" title="33 避免遮掩继承而来的名称"></a>33 避免遮掩继承而来的名称</h1><h2 id="同名覆盖的小例子"><a href="#同名覆盖的小例子" class="headerlink" title="同名覆盖的小例子"></a>同名覆盖的小例子</h2><p>继承中同名覆盖问题的核心知识点：作用域问题，例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> a;</span><br><span class="line">	cin&gt;&gt;a; <span class="comment">//使用double a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现象：内层作用域会覆盖外层作用域的同名变量，而无论变量的类型。<br>原因：当编译器遇到a时，首先在local作用域查找该变量，找到则停止向外查找，而无论这个变量的类型，这就是C++名称遮掩规则。</p>
<h2 id="继承中的同名覆盖"><a href="#继承中的同名覆盖" class="headerlink" title="继承中的同名覆盖"></a>继承中的同名覆盖</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">d.<span class="built_in">func3</span>(<span class="number">5</span>); <span class="comment">//错误</span></span><br><span class="line">d.<span class="built_in">func3</span>(); <span class="comment">//错误</span></span><br><span class="line">d.<span class="built_in">func3</span>(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//正确，调用派生类Derived中func3(int,int)。</span></span><br></pre></td></tr></table></figure>

<p>这是因为derived的作用域是嵌入在Base的作用域中的，对func3的查找先在Derived作用域中进行。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>（1）采用using声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::fun3; <span class="comment">// 让Base内名为func3的函数在Derived的作用域中可见</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）采用转交函数</p>
<p>using声明将使得Base类中所有fun3都在Derived中可见，但如果我们只想继承无参版本，可以利用名称掩盖的规则，声明一个同样的无参版本，去调用Base的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123; <span class="comment">//forwarding function</span></span><br><span class="line">    Base::<span class="built_in">fun3</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="34-区分接口继承与实现继承"><a href="#34-区分接口继承与实现继承" class="headerlink" title="34 区分接口继承与实现继承"></a>34 区分接口继承与实现继承</h1><p>表面上直截了断的public继承，通过更严密的检查后，实际上分为“接口继承”和“实现继承”两部分。</p>
<p>我们在基类中会有：</p>
<ul>
<li>纯虚函数</li>
<li>虚函数</li>
<li>普通函数</li>
</ul>
<p>派生类继承基类的这几种函数分别意味着什么？</p>
<ul>
<li>纯虚函数意味着派生类只继承函数接口（因为需要派生类自己实现）；</li>
</ul>
<blockquote>
<p>重要：虽然纯虚函数在基类可以有实现，但是派生类仍然需要自己实现一份。</p>
</blockquote>
<ul>
<li>虚函数意味着派生类继承一份接口与一份默认实现；</li>
<li>普通函数意味着派生类继承一份接口与强制实现。</li>
</ul>
<h1 id="35-考虑虚函数以外的选择"><a href="#35-考虑虚函数以外的选择" class="headerlink" title="35 考虑虚函数以外的选择"></a>35 考虑虚函数以外的选择</h1><p>NVI（Non-Virtual interface）利用公有函数调度private虚函数，好处是可以加一些代码在虚函数调用周围。</p>
<p>Strategy设计模式</p>
<p>借由std::function完成Strategy设计模式：</p>
<ul>
<li>既能传入函数</li>
<li>也能传入仿函数</li>
<li>成员成员（通过std::bind绑定函数与对象）</li>
</ul>
<h1 id="36-绝不重新定义继承而来的non-virtual-函数"><a href="#36-绝不重新定义继承而来的non-virtual-函数" class="headerlink" title="36 绝不重新定义继承而来的non-virtual 函数"></a>36 绝不重新定义继承而来的non-virtual 函数</h1><p>避免同名覆盖！</p>
<h1 id="37-绝不重新定义继承而来的缺省参数值"><a href="#37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="37 绝不重新定义继承而来的缺省参数值"></a>37 绝不重新定义继承而来的缺省参数值</h1><p>virtual函数是动态绑定的，缺省参数是静态绑定的。</p>
<p>这点的矛盾会让你使用时出现un-expected行为。</p>
<h1 id="39-关于private继承"><a href="#39-关于private继承" class="headerlink" title="39 关于private继承"></a>39 关于private继承</h1><p>第一条规则：如果class之间是private继承，那么将派生类对象转化为基类对象。</p>
<p>第二条规则：基类中的成员都会被贬为private在派生类中。</p>
<p>借条款34所言：private继承是纯粹继承实现，略去接口。它描述的是组合关系，其意义只在于软件实现方面。</p>
<h1 id="41隐式接口与编译期多态"><a href="#41隐式接口与编译期多态" class="headerlink" title="41隐式接口与编译期多态"></a>41隐式接口与编译期多态</h1><p>（1）多态</p>
<p>编译期多态：哪一个重载函数应该被使用。</p>
<p>运行期多态：哪一个虚函数应该被绑定。</p>
<p>（2）接口</p>
<p>显式接口：函数签名式（函数名称、参数类型、返回类型）</p>
<p>隐式接口：在模版中，T的类型并不知道，知道T需要满足的某些条件（比如必须有xx函数、支持xx operaotr），同时因为隐式转换存在，对象可被转换成另外一个对象调用。</p>
<h1 id="48-认识template元编程"><a href="#48-认识template元编程" class="headerlink" title="48 认识template元编程"></a>48 认识template元编程</h1><p>元编程将工作从运行期转移到编译期，从而使得某些在运行期的错误在编译期中抛出。</p>
<p>尽管有些代码逻辑在运行期间不会被执行，但是编译器必须确保所有源码都是符合语法规则有效的。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Effective C++ 读书笔记2</p><p><a href="https://xyz.desirer233.fun/2025/06/15/C++/effecitve C++读书笔记2/">https://xyz.desirer233.fun/2025/06/15/C++/effecitve C++读书笔记2/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-06-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-07-20</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/06/15/C++/effective%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Effective C++ 读书笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/05/25/C++/%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E4%B8%8E%E8%A6%86%E7%9B%96/"><span class="level-item">重载重写与覆盖</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#29-为异常安全努力是值得的"><span class="level-left"><span class="level-item">1</span><span class="level-item">29 为异常安全努力是值得的</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#copy-and-swap策略"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">copy and swap策略</span></span></a></li></ul></li><li><a class="level is-mobile" href="#30-了解inline的里里外外"><span class="level-left"><span class="level-item">2</span><span class="level-item">30 了解inline的里里外外</span></span></a></li><li><a class="level is-mobile" href="#31-将文件间的编译依存关系降至最低"><span class="level-left"><span class="level-item">3</span><span class="level-item">31 将文件间的编译依存关系降至最低</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#编译依存关系"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">编译依存关系</span></span></a></li><li><a class="level is-mobile" href="#前置声明"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">前置声明</span></span></a></li><li><a class="level is-mobile" href="#PImpl"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">PImpl</span></span></a></li></ul></li><li><a class="level is-mobile" href="#32-确定你的public继承塑模出is-a关系"><span class="level-left"><span class="level-item">4</span><span class="level-item">32 确定你的public继承塑模出is-a关系</span></span></a></li><li><a class="level is-mobile" href="#33-避免遮掩继承而来的名称"><span class="level-left"><span class="level-item">5</span><span class="level-item">33 避免遮掩继承而来的名称</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#同名覆盖的小例子"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">同名覆盖的小例子</span></span></a></li><li><a class="level is-mobile" href="#继承中的同名覆盖"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">继承中的同名覆盖</span></span></a></li><li><a class="level is-mobile" href="#解决方法"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">解决方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#34-区分接口继承与实现继承"><span class="level-left"><span class="level-item">6</span><span class="level-item">34 区分接口继承与实现继承</span></span></a></li><li><a class="level is-mobile" href="#35-考虑虚函数以外的选择"><span class="level-left"><span class="level-item">7</span><span class="level-item">35 考虑虚函数以外的选择</span></span></a></li><li><a class="level is-mobile" href="#36-绝不重新定义继承而来的non-virtual-函数"><span class="level-left"><span class="level-item">8</span><span class="level-item">36 绝不重新定义继承而来的non-virtual 函数</span></span></a></li><li><a class="level is-mobile" href="#37-绝不重新定义继承而来的缺省参数值"><span class="level-left"><span class="level-item">9</span><span class="level-item">37 绝不重新定义继承而来的缺省参数值</span></span></a></li><li><a class="level is-mobile" href="#39-关于private继承"><span class="level-left"><span class="level-item">10</span><span class="level-item">39 关于private继承</span></span></a></li><li><a class="level is-mobile" href="#41隐式接口与编译期多态"><span class="level-left"><span class="level-item">11</span><span class="level-item">41隐式接口与编译期多态</span></span></a></li><li><a class="level is-mobile" href="#48-认识template元编程"><span class="level-left"><span class="level-item">12</span><span class="level-item">48 认识template元编程</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cmu15445/"><span class="level-start"><span class="level-item">cmu15445</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/cmu15445/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/buttonRPC/"><span class="level-start"><span class="level-item">buttonRPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/muduo%E7%BD%91%E7%BB%9C%E5%BA%93/"><span class="level-start"><span class="level-item">muduo网络库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/GDB/"><span class="level-start"><span class="level-item">GDB</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/IDE/"><span class="level-start"><span class="level-item">IDE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="level-start"><span class="level-item">命令行</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"><span class="level-start"><span class="level-item">PostgreSQL</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/openGauss/"><span class="level-start"><span class="level-item">openGauss</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/"><span class="level-start"><span class="level-item">计算机工程</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2026 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>