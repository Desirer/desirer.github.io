{"posts":[{"title":"Learn Vim Efficiently 1","text":"前言：学linux时接触了vim这个编辑器，当时只知道三种模式转换，并不觉得vim有多好用。 缘起：看南大蒋炎岩操作系统课程时，jyy在shell上键指如飞，我就思考为什么他能够编辑得这么快。我想到的一个点就是光标的移动。在没有接触vim之前，我都是通过键盘右下角的上下左右键进行光标的移动，这意味着右手需要移动一段距离。而接触vim之后，hjkl的移动映射只能说真香。现在我恨不得接触到的每个文本编辑器都有vim工作模式。 推荐阅读： https://github.com/iggredible/Learn-Vim https://missing.csail.mit.edu/2020/editors/ 快速体验：力扣刷题设置绑定vim键位，快速体验vim。 0 三种工作模式知道vim的三种工作模式 ：编辑模式（insert mode）、命令行模式（command line mode）、正常模式（normal mode） 编辑模式：最一般的文本编辑 按i进入，&lt;Esc&gt;退出 命令行模式：保存文件，离开，读入文件，显示行号等 按:显示，&lt;Esc&gt;退出 正常模式：光标移动、删除、复制粘贴、查找替换 初始模式，&lt;Esc&gt;总能返回normal mode 推荐将&lt;Esc&gt;键位映射至&lt;Caps&gt;键位。 1 hjkl光标移动与插入模式在normal mode下，可以通过hjkl键进行光标的移动，练会以后很香。 光标移动： 123456h Leftj Downk Upl Rightw 移动到下一个单词（挖坑、w和W区别）b 反向移动到下一个单词 插入模式： i 光标之前 I 本行开头 a 光标之后 A 本行结尾 o 本行之后新增一行插入 O 本行之前新增一行插入 s 删除当前字符插入 S 删除当前行插入 2 复制粘贴撤销删除在normal mode下可以进行以下操作： yy 复制当前行 （y代表 yank） dd 剪切当前行 p 粘贴 paste u 撤销 undo （挖坑，u撤销的到底是什么？） &lt;ctrl-r&gt; 重做 redo 3 可视化编辑 v 文本块编辑 V 行块编辑 Ctrl-v 块编辑 123y Yank text (copy)d Delete text and save to registerc Delete text, save to register, and start insert mode 后序： 本文以学windows文本编辑器的逻辑介绍了vim。学vim重要的是提高效率，如何快速入门vim？我想是掌握最常用的操作，抛弃那些看起来效率很高但是使用频率低的操作（比如e、E、ge、gE），这些只会徒增记忆的烦恼。待到使用这些命令成为肌肉记忆时，再学习也不迟。 好了，学会以上这些就算简单入门了，实际上vim还有更多命令，能带来效率质的提高。看不如动手，去力扣刷题吧，感受vim的魅力。","link":"/2023/11/22/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/Vim-1/"},{"title":"Learn Vim Efficiently 2","text":"这里将介绍vim的语法和光标浏览，这几乎是vim最重要的部分。 一、语法强烈推荐阅读： https://github.com/iggredible/Learn-Vim/blob/master/ch04_vim_grammar.md 不同于其他文本编辑器的快捷键（需要同时按下两个键或者三个键），vim的命令更像是编程，有一套特定的语法。 在vim中只有一个语法规则： 1动词+名词 1.1 动词所谓动词就是Operator，操作符。 用:h operator可以查看16种操作符，这里列举三种最常用的操作符。 123y Yank text (copy)d Delete text and save to registerc Delete text, save to register, and start insert mode 1.2 名词所谓名词就是motions，你用来在vim中移动的符号。这里是一些motions。 1234567h Leftj Downk Upl Rightw 移动到下一个单词b 反向移动到下一个单词$ 移动到本行末尾 1.3 动词+名词的语法体现假设你有如下文本： 1cosnt string learn = “vim”; 在正常模式下，你的光标在字母c上。 复制一整行:y$ y是复制，$是移动到一行末尾 删除const：dw d删除w一个单词 向左拷贝3个字母：y3h 删除2个单词：d2w 所以vim的命令不需要刻意记忆，就像自然语言。 以行为单位的操作很频繁，所以vim将准备了一些行操作的快捷方式：yy,dd和cc 1.4 更加快捷的操作假设你有如下文本： 1234int print(){ console.log(&quot;hello vim&quot;); int a[15];} 快速删除括号内的内容di( 快速删除双引号里的内容di&quot; 快速删除中括号内的内容di[ 这将是vim的必杀技。di代表着delete inner。对于结构化的文本，特别是代码。 12i + object Inner text objecta + object Outer text object da(将会连括号一起删除。 1234567891011w A wordp A paragraphs A sentence( or ) A pair of ( ){ or } A pair of { }[ or ] A pair of [ ]&lt; or &gt; A pair of &lt; &gt;t XML tags&quot; A pair of &quot; &quot;' A Pair of ' '` A pair of ` ` 二、光标移动强烈推荐阅读： https://github.com/iggredible/Learn-Vim/blob/master/ch05_moving_in_file.md 光标移动是很基础且重要的内容，一般我们退出编辑模式就是进行光标的移动。 2.1 字符移动12345hjklN + Motion 比如说5H向左移动5个字符。 2.2 单词间移动顾名思义，在单词间移动。 12345w Move forward to the beginning of the next worde Move forward one word to the end of the next wordb Move backward to beginning of the previous word 一般命令都会有大写和小写两个版本，或者代表着两个方向，或者代表着两个不同的意思。 123456W Move forward to the beginning of the next WORDE Move forward one word to the end of the next WORDB Move backward to beginning of the previous WORDge Move backward to end of the previous wordgE Move backward to end of the previous WORD 那么大写的单词和小写的单词有什么区别呢？单词都是被空白字符分隔的字符串。 小写单词只包括字母和数字 大写单词包括任何字符除了空格、制表符和 EOL 2.3 行间移动或者叫行内水平移动更佳。 1230 Go to the first character in the current line$ Go to the last char in the current linen| Go the column n in the current line 值得说是n|，在代码的报警信息中经常能看到第几行第几列报错，使用这个命令能快速定位到出错列。n代表任意数字。 快捷的操作：行内搜索。我认为这是vim的第二个必杀技。 12f Search forward for a match in the same linet Search forward for a match in the same line, stopping before match 利用f可以快速到达你想要的字符面前。比如说fa，快速将光标定位到第一个a的位置。 快速记住f和t的区别：f代表find，找到。t代表till，直到。 同样大小写两个版本代表着两个方向。 12345F Search backward for a match in the same lineT Search backward for a match in the same line, stopping before match; Repeat the last search in the same line using the same direction, Repeat the last search in the same line using the opposite direction 使用;和.能避免重复劳动。记住上次的 行内查找操作。 2.4 行号移动这才是名副其实的行间移动。比如说你想到第7行，命令7G 1234gg Go to the first lineG Go to the last linenG Go to line nn% Go to n% in file 2.5 搜索与替换终于来了，全文搜索与替换。 1234/ Search forward for a match? Search backward for a matchn Repeat last search in same direction of previous searchN Repeat last search in opposite direction of previous search 比如说，现在我们有这样一段文本： 123const int a = 1;const int b = 2;int c = 3; 现在我们想要将所有的int都替换为float： \\int&lt;Enter&gt; 这时你将定位到第一个int cwfloat&lt;Esc&gt; change word改变一个单词，然后输入float n. 继续下一个搜索，然后用点命令重复改变 这时你就能发现vim的快捷了。 还有一些快捷命令： 1234* Search for whole word under cursor forward# Search for whole word under cursor backwardg* Search for word under cursor forwardg# Search for word under cursor backward g*和*的作用，客观自行搜索。 2.6 窗口与浏览To scroll, you have 3 speed increments: full-screen (Ctrl-F/Ctrl-B), half-screen (Ctrl-D/Ctrl-U), and line (Ctrl-E/Ctrl-Y). 123456* Ctrl-E Scroll down a lineCtrl-D Scroll down half screenCtrl-F Scroll down whole screen* Ctrl-Y Scroll up a lineCtrl-U Scroll up half screenCtrl-B Scroll up whole screen You can also scroll relatively to the current line (zoom screen sight): 123zt Bring the current line near the top of your screen* zz Bring the current line to the middle of your screenzb Bring the current line near the bottom of your screen 这里留下作者的话： Finally, realize that you do not need to know every single Vim command to be productive. Most Vim users don’t. I don’t. Learn the commands that will help you accomplish your task at that moment. Take your time. Navigation skill is a very important skill in Vim. Learn one small thing every day and learn it well. 三、Vimrc3.1 是什么？vimrc是vim的配置文件。 3.2 有什么用？它能将某些设置永久保存。什么意思呢？比如说，你现在打开vim设置了行号:set number，当你下一次打开vim时，这个设置就失效了。通过vimrc就能永久保存设置。 一般vimrc在用户目录下， ~/.vimrc. 3.3 它有哪些内容？一般来说，vimrc主要配置以下内容： Plugins Settings Custom Funcitons Custom Commands Mappings 我们只挑常用的讲，设置settings和映射mappings。 当你改变vimrc时，记得source it。 Save it (:w), then source it (:source %). 3.4 设置你可以准备一些常用的设置： 12set numberset nocompatible Since we are learning about Vim and not Vi, a setting that you must have is the nocompatible option. Add set nocompatible in your vimrc. Many Vim-specific features are disabled when it is running on compatible option. 3.5 映射你可以将一些键位映射成一系列命令的组合。这是个非常有用的功能。比方说，你如果不习惯vim的hjkl你可以映射为类似方向键布局的jkli。 语法为： 1nnoremap &lt;key&gt; &lt;key&gt; n意味着normal模式 nore意味着non-recursive，不递归的 map就是映射 如何理解non-recursive呢？让我们来看一个例子： 你现在想要实现这样一个功能：按B就能在每一行的末尾加一个分号，然后退回到上一个单词。你写出这样： 1nmap B A;&lt;esc&gt;B 注意，A行末尾插入，分号，esc退回到normal模式，B回退一个单词。 这看起来很美好，但实际上这个命令会加无限多的分号。除非你按Ctrl-C停止。 为什么？因为没有设置不递归，最后一个B也被解释为映射后的B，而不是映射前的B（回退单词）。 所以，最好在平常中都使用不递归的映射。 好了，现在你可以实现一些快捷的功能了。 1inoremap jk &lt;esc&gt; 这个命令在插入模式下，同时按住jk就能退出插入模式。 map命令的首字母对应不同的模式，这里留给大家探索。 四、后序多用，多折腾。 这里留下作者的话： Vimrc is an important component of Vim customization. A good way to start building your vimrc is by reading other people’s vimrcs and gradually build it over time. The best vimrc is not the one that developer X uses, but the one that is tailored exactly to fit your thinking framework and editing style.","link":"/2023/11/22/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/VIm-2/"},{"title":"Learn Vim Efficiently 3","text":"这里介绍点命令、寄存器和宏。点命令比较有用，寄存器和宏比较鸡肋。 一、 点命令点命令 . 可以重复你在vim中的改变。 1.1 change in vim在vim中，究竟什么被视为一个改变？ 简单的来说，从进入插入模式到退出之间的所有操作！ 1.2 一个点命令的快捷使用方式比如说，现在我们有这样一段文本： 123const int a = 1;const int b = 2;int c = 3; 现在我们想要将所有的int都替换为float： \\int&lt;Enter&gt; 这时你将定位到第一个int cwfloat&lt;Esc&gt; change word改变一个单词，然后输入float n. 继续下一个搜索，然后用点命令重复改变 点命令的最佳使用场景就是变量更名，当你修改完一个变量的名字，移动光标到下一个变量，然后应用点命令。 二、寄存器在vim中有10种类型的寄存器，不过我并不打算全部介绍它们。 关于寄存器，我们要知道： 有哪些？ 怎么往寄存器里存值？ 怎么从寄存器里取值？ 2.1 start by 4 types register 匿名寄存器：&quot;&quot; 拷贝寄存器：&quot;0 数字寄存器：&quot;1-9 和字母寄存器：&quot;a-z small delete register：&quot;- 寄存器总是以双引号开头，后面跟着一个符号。 匿名寄存器，是我们最常用的寄存器。这里的常用，是它被vim使用，而不是我们主动显式地调用。之前讲的dd,yy,p快捷方式都是往匿名寄存器里存值或取值。 拷贝寄存器，是我们使用y操作符时关联的寄存器。注意yy命令会同时拷贝匿名寄存器和拷贝寄存器，利用这点我们就能得到一个缓存。比如说先用yy再用dd，此时匿名寄存器被更新，如果想用第一次复制的内容，需要从拷贝寄存器拉值&quot;0p。 数字寄存器和字母寄存器都是常规寄存器，主要是往里面存值和取值。 samll ddelete register主要用于小单词的存取。当你diw一个单词的时候，这个单词就会存在这个寄存器中。 2.2 寄存器存取值对寄存器的操作都很简单，用双引号来调用一个寄存器，后面跟上你的命令。 比如，现在你有以下文本： 1const int a = 1; &quot;ad3l&lt;esc&gt; 向左删除3个字符，存在寄存器a中 j 移动到下一行 &quot;ap 从寄存器a中取值 三、宏3.1 是什么？宏可以看作一系列操作的录制，它能帮助你避免许多的重复劳动，在你需要的时候自动执行预先录制好的操作。 3.2 录制宏如果要录制宏，当然需要一个能存储的宏的容器，在vim中，自然就是寄存器了。 录制宏 1q&lt;寄存器名&gt; 结束录制 1q 比如说，录制宏到寄存器4 1q4 之后，寄存器4会记录下你的每一个按键操作。 记得结束录制。 3.3 使用宏使用宏也很简单，用@调用存在寄存器里的宏。 1@&lt;寄存器名&gt; 或者 1@@ Execute the last executed macros 这个命令直接执行上一次录制的宏。 举一个例子：我们想要大写每一个单词 12345hellovimmacrosareawesome With your cursor at the start of the line “hello”, run: 1qa0gU$jq The breakdown: qa starts recording a macro in the a register. 0 goes to beginning of the line. gU$ uppercases the text from your current location to the end of the line. j goes down one line. q stops recording. To replay it, run @a. Just like many other Vim commands, you can pass a count argument to macros. For example, running 3@a executes the macro three times.","link":"/2023/11/22/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/vim-3/"},{"title":"Git快速入门","text":"Git是一个版本控制工具，通常配合远程代码仓库多人协作开发。上手Git并不难，用过之后就会觉得真香。我入门的方式就是给一个项目提Pull Request。 git学习思路：单链 -&gt; 树 -&gt; 多棵树 本地版本控制（利用状态机的思想学习Git） 分支版本控制（利用树的思想） 远程仓库控制（两颗树之间的对应！） 最后学习学习git相关的配置文件，git就算简单入门了。 推荐阅读：https://www.progit.cn/#_pro_git 在线Git闯关-图形化学GIt：https://learngitbranching.js.org/?locale=zh_CN 一、git基础工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录。 未跟踪文件是工作目录中除已跟踪文件以外的所有其它文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 经过Git追踪的文件，在工作一段时间后，它们可能处于其中之一的状态： committed 已经提交，数据在本地仓库中 modified 已经修改，没有保存在数据库中 staged 已经暂存，包含在下次提交的快照中 引入Git项目三个工作区域的概念：Git仓库、工作目录、暂存区域 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 二、本地版本控制2.1 获取仓库获取仓库的方法： 现有目录初始化仓库 克隆仓库 （1）现有目录初始化仓库 1234git init git add your_filegit add LISCENSEgit commit -m 'initial project version' （2）克隆仓库 1git clone [url] 比如 1git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹。 如果你想在克隆远程仓库的时候自定义本地仓库的名字， 在上条命令后面跟着你自定义的名字： 1git clone https://github.com/libgit2/libgit2 your_local_name 2.2 git状态工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 未跟踪文件是工作目录中除已跟踪文件以外的所有其它文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。这就是Git本地工作的思想。 2.3 git操作（1）查看文件状态1$ git status （2）跟踪新文件（untracked -&gt; staged)1$ git add yourfile 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 （3）暂存已修改文件 (modified -&gt; staged)1$ git add yourfile （4）忽略文件在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。这些文件不会被提交。 （5）提交更新12$ git commit//另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。 在提交前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 每次准备提交前用 git status 看下，是不是都已暂存起来了。 （6）跳过暂存1git commit -a 跳过暂存步骤，将已跟踪的文件（若已经修改）提交。 （7）移除文件xx （8）版本回滚首先查看提交的各个版本提交的 SHA-1 标识符。两个命令都行，不过第二个显示的信息更加简洁。 12$ git log --pretty=oneline$ git log --oneline 使用 git revert 命令可以创建一个新的提交，它撤销了指定的提交内容，但是保留了原来的提交记录。 1git revert SHA-1 使用 git reset 命令可以回滚提交，但这种方式是破坏性的，因为它会更改 Git 历史记录，从而删除要回滚的提交以及回滚之后的提交。 1git reset --hard SHA-1 使用reset后就不能恢复了！ （9）放弃暂存区的修改，回到上次提交要放弃本次代码修改并将工作区回到上次提交的状态，可以使用命令： 1git checkout -- . 该命令会将工作区中所有文件的修改全部还原到上次提交的状态，注意命令中的点号”.”表示当前目录，也可以替换成具体的文件或目录名。 此外，如果你只是想还原某个特定文件的修改，可以使用： 1git checkout -- 文件名 注意，这个命令并不会从版本库中删除已经提交的修改记录，只是还原到上次提交。 如果需要完全撤销某个提交，使用 git reset 命令。 三、分支版本控制3.0 查看分支1git branch 这个命令可以查看当前的所有分支。 1234$ git branch iss53* master testing 注意 master 分支前的 * 字符：它代表现在位于的分支（当前 HEAD 指针所指向的分支）。 3.1 查看分支指向的对象分支指向的对象指commit的文件对象。 123git log --oneline --decorategit log --decorate git log --oneline --decorate 输出效果： 123位于分支 master2348425 (HEAD -&gt; master, testing) v265cd212 initial commit!# 当前 HEAD 指针所指向的分支是master，代表当前所在分支。 3.2 创建分支1git branch your_name 这会在当前提交对象上创建your_name的一个指针，代表创建了一个分支。 3.3 切换分支1git checkout branch_name 切换到branch_name这条分支。实际上会将head指针指向branch_name上。输出效果： 122348425 (HEAD -&gt; testing, master) v265cd212 initial commit!# （1）当你在testing分支提交时，会像现在这样： 123dcd85fe (HEAD -&gt; testing) add file a.c2348425 (master) v265cd212 initial commit!# （2）当你切换回mater分支时,head指针会指向master。 注意：你的工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。 （3）当你在master分支上再次提交修改时，你的项目就会产生分叉！ 1git log --oneline --decorate --graph --all 它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 12345* c8f77ad (HEAD -&gt; master) somethign fixed| * dcd85fe (testing) add file a.c|/* 2348425 v2* 65cd212 initial commit!# Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 3.3 分支工作流（1）创建并切换到新分支 1git checkout -b issue54 （2）删除分支 1git branch -d hostfix （3）合并分支 12345678//先切换到master分支$ git checkout masterSwitched to branch 'master'//然后将iss53分支合并到master分支$ git merge iss53Merge made by the 'recursive' strategy.index.html | 1 +1 file changed, 1 insertion(+) 和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。 3.4 遇到冲突时的合并如果两次合并都涉及同一个文件的同一处修改，在合并它们的时候就会产生冲突。 此时需要手动排除冲突。步骤： git status 查看冲突的文件 逐一打开冲突文件修改 git add将修改完的文件放入暂存区 git commit提交修改 3.5 放弃合并1git merge --abort 有时候冲突太多了，直接放弃合并吧。 3.6 分支开发工作流比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。 四、远程仓库控制4.1 查看远程仓库12$ git remoteorigin 它会列出你指定的每一个远程服务器的简写。默认情况下就只有一个origin。 使用选项 -v，会显示远程仓库使用的 Git 保存的简写与其对应的 URL。 123$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push) 4.2 添加远程仓库1git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个你可以引用的简写。 比如： 12345678$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) 先查看现在有远程仓库，只有一个origin。然后添加一个简写为pb的远程仓库。再此查看对应的远程仓库，发现pb已经添加上了。 4.3 从远程仓库抓取fetch1$ git fetch [remote-name] 这个命令会访问远程仓库，拉取所有你还没有的数据（包括新的分支）。 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 4.4 推送到远程仓库push1git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 将你本地的某个分支推送到远程的某个分支。两个分支名可以不相同。 如果一个本地分支和远程分支建立了联系（下节会讲，所谓联系就是一一对应），直接 git push就能推送到对应的远程分支。 4.5 跟踪分支track跟踪实际上意味着将本地分支与远程分支建立联系。 (1) 查看本地分支与远程分支之间的关系1git branch -vv 样例输出： 123 develop 3e7f1c3 [origin/develop: ahead 2] Fix bug #123 feature-abc 12a8ee2 [origin/feature-abc] New feature implementation* main 4d59b46 [origin/main: ahead 1, behind 2] Merge pull request #456 这个输出列出了本地仓库中的三个分支：develop、feature-abc和main。其中，星号(*)表示当前所在的分支是main。 对于每个分支，输出显示了以下信息： 分支名称 分支所依据的提交哈希值 与之对应的远程分支名称及其状态信息 在这个示例中，develop分支有两个本地提交尚未推送到远程，而feature-abc分支只有与远程分支同步的提交。同时，main分支有一个本地提交，需要将其推送给远程，并且还需要从远程拉取两个提交。 1、当克隆一个仓库时，git通常会自动地创建一个跟踪 origin/master 的 master 分支。 2、需要重点注意的是这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 git fetch --all (2) 跟踪一个远程分支（重要）1git checkout -b [local_branch] [remote_name]/[remote_branch] 这个命令会自动创建一个本地分支并跟踪远程分支。 这是一个十分常用的操作，所以 Git 提供了 --track 快捷方式： 1$ git checkout --track origin/[remote_branch] 直接创建本地的同名分支，跟踪远程分支。比如： 1git checkout --track origin/bugfix-update-v1.1 这会建立一个本地分支origin/bugfix-update-v1.1，它会自动与远程同名分支建立联系。 (3) 修改本地分支跟踪的远程分支1$ git branch -u [remotename]/[remote_branch] 这条命令将设置当前分支跟踪的远程分支。 或者这条命令也有同样效果。 1$ git branch --set-upstream-to=[remotename]/[branch] 4.6 拉取分支pull1git pull git pull是指将远程仓库的代码更新到本地仓库，并合并到本地分支上。 具体来说，git pull命令相当于执行了两个命令： git fetch：从远程仓库拉取最新的代码，并将其存放在本地的“FETCH_HEAD”引用中，但不会修改本地分支。 git merge：将“FETCH_HEAD”引用合并到当前分支上，从而将最新的代码更新到本地仓库。 当执行git pull命令时，会自动执行以上两个步骤，从远程仓库拉取最新的代码，并合并到本地分支上，以使本地代码与远程仓库保持同步。 4.6 查看远程仓库查看某一个远程仓库的更多信息 1git remote show [remote-name] 重命名引用的名字 1git remote rename [old_name] [new_name] 比如将pb远程引用的仓库名称改为paul 1234$ git remote rename pb paul$ git remoteoriginpaul 五、打标签Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 5.0 为什么要打标签（1）A tag is immutable！ Tag是不可变的，在合入主分支与发布的期间，不必担心任何非预期的改变。 （2）便于管理 标签可比提交带有更多的信息。 5.1 列出标签123$ git tagv0.1v1.3 也可以使用特定的模式查找标签。 1$ git tag -l 'v1.8.5*' 六、git的配置6.1 gitconifg文件（1）是什么？ .gitconfig 文件是 Git 的配置文件，在系统上一般位于用户主目录下。这个文件包含了 Git 的一些全局配置，例如 Git 用户名、邮箱地址、文本编辑器等。 （2）怎么用？ 通过修改 .gitconfig 文件，可以定制 Git 的行为。下面是一些可以在 .gitconfig 文件中设置的常用配置： user.name：设置 Git 的用户名，例如git config --global user.name &quot;Your Name&quot;。 user.email： 设置 Git 的邮箱地址，例如 git config --global user.email &quot;youremail@example.com&quot;。 core.editor：设置 Git 使用的文本编辑器，例如 git config --global core.editor &quot;vim&quot;。 core.autocrlf：将文本文件在 Windows 和 Unix 之间自动进行换行符转换，以便在不同平台之间协作，例如git config --global core.autocrlf true。 alias：自定义 Git 命令别名，例如 git config --global alias.st status 将 git status 命令设置为 git st 命令的别名。 可以通过运行以下命令打开 .gitconfig 文件： 1git config --global --edit 这将在系统中打开 Git 配置文件，可以进行编辑。在 .gitconfig 文件中进行修改后，新的设置会对所有 Git 仓库生效。 6.2 gitignore_global文件（1）是什么？ .gitignore_global 文件是 Git 的全局忽略文件。在这个文件中写入的文件或文件夹将不会被 Git 追踪或提交到远程仓库中。这个文件不同于普通的 .gitignore 文件，它适用于所有的 Git 仓库，而不仅仅是单个项目。 .gitignore_global 文件的作用是防止 Git 追踪某些类型的文件或目录。例如，Windows 系统自动生成的 Thumbs.db 文件、macOS 下的 .DS_Store 文件以及 Python 等语言生成的 .pyc、.pyo 文件等都可以在这个文件中被忽略。当对多个 Git 仓库工作时，这是非常有用的，可以避免在未意识到的情况下提交不必要的文件，从而节省仓库的空间和管理工作。 （2）怎么用？ 要在 Git 中启用全局忽略文件，请在命令行中运行以下命令： 1git config --global core.excludesfile ~/.gitignore_global 其中 ~/.gitignore_global 是 .gitignore_global 文件的路径，可以根据实际情况修改路径。运行此命令后，Git 将不再追踪或提交 .gitignore_global 文件中列出的任何文件或目录。 （3）文件怎么配置？ 在 ~/.gitignore_global 文件中，您可以放置您希望在所有 Git 仓库中忽略的文件或文件夹的模式（通配符格式）。这将使 Git 忽略这些文件或文件夹，即使它们没有被放入 .gitignore 文件中。 例如，如果您希望 Git 在所有仓库中忽略 .DS_Store 文件和 __pycache__ 文件夹，可以创建一个 ~/.gitignore_global 文件，并在其中添加以下内容： 1234# Ignore all .DS_Store files.DS_Store# Ignore pycache directory__pycache__/ 然后，使用 git config 命令将路径添加到 Git 全局配置中，使其生效： 1git config --global core.excludesfile ~/.gitignore_global 这样，在任何 Git 仓库中，都将忽略 .DS_Store 文件和 __pycache__ 文件夹。","link":"/2023/12/01/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/Git-fast-learning/"},{"title":"Missing Semmster Learning 学习笔记","text":"计算机教学中缺失的一课 ：https://missing.csail.mit.edu/ 笔记很丑，不想再改。 一、Course overview + the shell认识shell。shell直译为壳，比喻为操作系统内核外面的一层，是我们同内核对话的一个界面。 推荐阅读：https://wangdoc.com/bash/intro bash是最常用的shell，可以把它当作一种编程语言，命令解释器。以下学习的就是bash的相关命令。 1.1 shell命令入门123echo &quot;hello world&quot;echo 'hello world'echo hello\\ world echo的字符用双引号或单引号包含。也可以不用它们，但遇到空格时要用反斜杠转译空格。（因为空格默认为分隔符） 1.2 how system can find echo?123echo $PATHwhich echo/bin/echo &quot;hello world&quot; echo其实是一段小程序，它也有自己的代码。通过$PATH这个系统变量，就能知道操作系统在哪里寻找echo的可执行文件。 也可以通过指定可执行文件的路径的方式来执行特定的可执行文件。 1.3 navigting in the shell1234cdpwdls和ls -l绝对路径和相对路径 理解linux的路径是一颗树，根路径从/开始。绝对路径从根开始，相对路径是相对于当前目录。 1.4 connecting programsprograms always associated with tow stream: input stream and output streamredirection &lt; file and &gt; filewhen cat is not given any arguments, it prints contents from its input stream to its output stream 12cat &lt; hello.txt| pipe command unix系统设计的哲学： 程序默认从键盘接受输入，输出到屏幕。（即每个程序关联标准输入流，标准输出流） 通过左右箭头符号可以重定向输入输出 管道可以将上一个程序的输出导入到下一个程序的输入 二、Shell Tools and Scriptingshell scripting, about learning a new language: basic data type Control flow If case while for syntax shell编程就是学新的编程语言，你需要知道： 数据类型 程序控制流 具体语法 2.1 variable如何定义变量？直接写出变量名，紧跟着等于号，最后是值。注意中间不能有空格。 1foo=bar # foo = bar is wrong 双引号和单引号在shell程序中的区别在于里面的变量是否会被解释。单引号不会解释变量。 12echo &quot;$foo&quot; # this print barecho '$foo' # this print $foo 2.2 function1234mcd () { mkdir -p &quot;$1&quot; cd &quot;$1&quot;} $0 name of program $1-9 arguments to the script $# number of arguments $$ pid $@ all the arguments $? the last command’s exit status 定义函数也非常简单，xxx。 2.3 Logical command123|| &amp;&amp;; # simplely seperate current command and the next command 或逻辑、与逻辑、单纯的分隔符。在命令行环境中也能使用。 2.4 command substitution1echo &quot;start program at $(date)&quot; 这就是先前讲的，双引号内的命令会被解释执行。前提是用$()包围。 2.5 Process substitution1234&lt;(cmd) # this will execute cmd and place the output in a temporary file and substitute the# &lt;() with that file's name 在Bash中，”&lt;(cmd)”是一种称为”Process Substitution”的特殊语法，它允许将命令的输出作为文件传递给另一个命令。 具体来说，”&lt;(cmd)”会将命令cmd的输出作为一个临时文件，并将该文件的路径作为参数传递给当前命令。 这个临时文件只存在于命令执行期间，并在命令执行完毕后自动删除。 2.6 wildcards and curly braces Wildcards - Whenever you want to perform some sort of wildcard matching, you can use ? and * to match one or any amount of characters respectively. For instance, given files foo, foo1, foo2, foo10 and bar, the command rm foo? will delete foo1 and foo2 whereas rm foo* will delete all but bar. Curly braces {} - Whenever you have a common substring in a series of commands, you can use curly braces for bash to expand this automatically. This comes in very handy when moving or converting files. 1234567891011121314151617181920212223convert image.{png,jpg}# Will expand toconvert image.png image.jpgcp /path/to/project/{foo,bar,baz}.sh /newpath# Will expand tocp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath# Globbing techniques can also be combinedmv *{.py,.sh} folder# Will move all *.py and *.sh filesmkdir foo bar# This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/htouch {foo,bar}/{a..h}touch foo/x bar/y# Show differences between files in foo and bardiff &lt;(ls foo) &lt;(ls bar)# Outputs# &lt; x# ---# &gt; y 通配符的概念无需多言。？表示任意一个字符，*表示任意多个字符。 大括号的作用比较微妙。有点像for循环遍历列表，然后自动展开。 这三个符号能极大的拓展匹配，实现自动化操作。 2.7 shebang line1#!/bin/bash Shebang line是指在脚本文件的第一行中使用特定格式的注释来指定解释器的路径。Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符串行 *#!*。 Shebang line的作用是告诉系统应该使用哪个解释器来执行脚本，从而使脚本能够正确地运行。 Some differences between shell functions and scripts that you should keep in mind are: Functions have to be in the same language as the shell, while scripts can be written in any language. This is why including a shebang for scripts is important. Functions are loaded once when their definition is read. Scripts are loaded every time they are executed. This makes functions slightly faster to load, but whenever you change them you will have to reload their definition. Functions are executed in the current shell environment whereas scripts execute in their own process. Thus, functions can modify environment variables, e.g. change your current directory, whereas scripts can’t. Scripts will be passed by value environment variables that have been exported using export As with any programming language, functions are a powerful construct to achieve modularity, code reuse, and clarity of shell code. Often shell scripts will include their own function definitions. differences between shell functions and scripts functions are executed in the current shell environment scripts execute in their own process 执行shell脚本其实是另外开了一个进程执行，所以当前环境不受影响。 1source xx.sh 而source一个shell脚本其实是加载脚本内的变量，这会影响当前环境变量。 2.8 shell tools123456find grepuniqsortwcawk 一些好用的小工具： TLDR pages Tree fasd autojump nnn 五、Command-line Environment提升你的shell工作流。 5.1 job control你的shell使用一种叫做信号的机制在进程间沟通。信号是一种软中断机制。 123ctrl-c 传递SIGINT信号ctrl-\\ 传递SIGQUIT信号ctrl-z 传递SIGTSTP信号，short for Terminal Stop SIGTERM signal ask a process to exit. Using kill command to send it. kill jobs fg bg nohup 5.2 terminal multiplexerstmux教学 leading key &lt;C-b&gt; x means you press ctrl and b, then release them together, and then press x panes 123竖直分裂一个窗口 &lt;C-b&gt; %水平分裂一个窗口 &lt;C-b&gt; &quot;关闭当前窗口 exit or ctrl-d windows - equivalent to tabs in browsers(threads in process) 123&lt;C-b&gt; c 创建一个虚拟桌面&lt;C-b&gt; p 切换上一个&lt;C-b&gt; n 切换下一个 sessions - a session is an independent workspace with one or more windows 12345tmux # start a new sessiontmux new -s NAME # start a new session with nametmux ls #ls current sessionsdetach a session with &lt;C-b&gt; dattach a session `tmux a` , with -t to specify which 5.3 Aliases1alias name=&quot;command arg1 arg2&quot; 为你的常用命令设置别名，减少重复劳动。 使用alias可以查看设置的别名。 常见的别名设置： 1todo 5.4 Dotfiles隐藏文件，通常是各种程序的配置文件。 bash ~/.bashrc or~/.bash_profile git ~/.gitconfig vim ~/.vimrc tmux ~/.tmux.conf ssh~/.ssh/config 关于隐藏文件，我们需要知道三件事： 内容 位置 管理 5.5 Remote Machines（1）ssh远程登录 1ssh user@remote_server_name ssh远程登录十分重要。 1ssh user@remote_server_name command 如果只执行一条命令，不想登录远程主机。 1ls | ssh user@remote_server_name grep PATTERN 这条命令会先将本地ls的输出通过管道传送到远程机器的grep上。是不是很神奇。这就是Unix的设计哲学。 （2）如果你不想每次都输入密码，利用非对称加密算法中的公钥和私钥，就能免去麻烦。 Key generationTo generate a pair you can run ssh-keygen. 1ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519 You should choose a passphrase, to avoid someone who gets hold of your private key to access authorized servers. Use ssh-agent or gpg-agent so you do not have to type your passphrase every time. If you have ever configured pushing to GitHub using SSH keys, then you have probably done the steps outlined here and have a valid key pair already. To check if you have a passphrase and validate it you can run ssh-keygen -y -f /path/to/key. Key based authenticationssh will look into .ssh/authorized_keys to determine which clients it should let in. To copy a public key over you can use: 1cat .ssh/id_ed25519.pub | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys' A simpler solution can be achieved with ssh-copy-id where available: 1ssh-copy-id -i .ssh/id_ed25519 foobar@remote （3）文件传输 ssh+tee 1cat localfile | ssh remote_server tee serverfile tee命令读标准输入到一个文件中。 scp 1scp path/local_file remote_host:path/remote_file scp可以像cp一样，将本地文件cp到远程路径 rsync 增强的scp，不过多深入。 （4）端口转发 本地端口转发：发送给本地端口的请求发送到远程机器上 远程端口转发：远程机器监听请求，将请求转发给本地机器 1ssh -L local_ip:local_port:remote_ip:remote_port user@remote_seerver 这是本地端口转发的语法，L表示本地端口转发。本地网卡端口是可以省略的，这时表示local port绑定了本地主机所有的网卡。 比如： 1$ ssh -L 9999:localhost:8888 user@remote_server 通过访问本地localhost:9999就能访问远程服务器的localhost:8888服务。 了解跳板机的概念：https://developer.aliyun.com/article/1035160 5.6 Shells &amp; FrameworksOn-my-zsh Syntax-highlighting History-substring-search 框架是件美好的事情。","link":"/2023/12/01/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E7%BB%88%E7%AB%AF/missing-semester-note/"},{"title":"终端基础知识","text":"命令行、终端、Shell、Promt的基础认知。 操作系统自带的终端都很丑且难用，好用的终端需要一番折腾配置（特别是国内环境网络问题），新手往往望而生畏。 【在学校没有人教你的终端基础知识】 https://www.bilibili.com/video/BV1rk4y1W7dZ 一、CLICLI is the abbreviation of Command Line Interface. It’s a text-based way of interacting with a computer. 相比于图像界面提供的按钮，你可以使用一行命令来实现你想要的功能，比如说打开、关闭文件，从而实现与计算机的交互。 那么，你在哪里输入这种文本命令？ 二、TerminalTerminal直译为终端，什么是终端？你可以理解为计算机与人们之间沟通的桥梁。通常它是一个全黑的窗口，可以输入命令并提供反馈。 终端是一款软件，许多系统都有自带的终端。也可以使用其他的终端软件。 三、ShellShell直译为壳，这里不必纠结翻译问题。 Shell运行在终端中，解释你的输入并执行它们。可以简单理解为一个命令解释器，不同的shell有不同的语法。 你输入的文本就好比日常生活中人与人沟通的话，计算机有自己的二进制语言，你有自己的一套语言，比如汉语、英语、法语、日语，Shell就在其中充当翻译官的角色。 四、Prompt命令提示符。在终端中，命令提示符用来提示你输入。比如说提示你当前所在的路径等等","link":"/2023/12/01/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E7%BB%88%E7%AB%AF/%E7%BB%88%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"categories":[{"name":"工具学习","slug":"工具学习","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"},{"name":"Vim","slug":"工具学习/Vim","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"},{"name":"Git","slug":"工具学习/Git","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"},{"name":"终端","slug":"工具学习/终端","link":"/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E7%BB%88%E7%AB%AF/"}],"pages":[]}