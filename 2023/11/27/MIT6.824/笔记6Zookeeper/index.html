<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MIT6824笔记六 线性一致与Zookeeper - Desirer&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Desirer&#039;s blog"><meta name="msapplication-TileImage" content="/images/icon2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Desirer&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这节课主要介绍了线性一致的概念与Zookeeper论文。 线性一致描述的是系统的行为，正确的行为是客户端发送了一个写请求并且收到服务端答复后，这个写请求能被之后的读请求看到。每个读请求看到的都是最新的写请求所作的更改。 Zookeeper论文是我接触到的最抽象的一篇论文。首先它的功能就很抽象：分布式协调内核。它提供的两个保证：线性写和FIFO客户端请求也费时间理解。最后则是它的API调用以及具体实"><meta property="og:type" content="blog"><meta property="og:title" content="MIT6824笔记六 线性一致与Zookeeper"><meta property="og:url" content="https://xyz.desirer233.fun/2023/11/27/MIT6.824/%E7%AC%94%E8%AE%B06Zookeeper/"><meta property="og:site_name" content="Desirer&#039;s blog"><meta property="og:description" content="这节课主要介绍了线性一致的概念与Zookeeper论文。 线性一致描述的是系统的行为，正确的行为是客户端发送了一个写请求并且收到服务端答复后，这个写请求能被之后的读请求看到。每个读请求看到的都是最新的写请求所作的更改。 Zookeeper论文是我接触到的最抽象的一篇论文。首先它的功能就很抽象：分布式协调内核。它提供的两个保证：线性写和FIFO客户端请求也费时间理解。最后则是它的API调用以及具体实"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://markdown.desirer233.fun/202312131353054.png"><meta property="article:published_time" content="2023-11-27T03:04:00.000Z"><meta property="article:modified_time" content="2024-06-09T13:00:22.510Z"><meta property="article:author" content="Desirer"><meta property="article:tag" content="分布式系统"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://markdown.desirer233.fun/202312131353054.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyz.desirer233.fun/2023/11/27/MIT6.824/%E7%AC%94%E8%AE%B06Zookeeper/"},"headline":"MIT6824笔记六 线性一致与Zookeeper","image":["http://markdown.desirer233.fun/202312131353054.png"],"datePublished":"2023-11-27T03:04:00.000Z","dateModified":"2024-06-09T13:00:22.510Z","author":{"@type":"Person","name":"Desirer"},"publisher":{"@type":"Organization","name":"Desirer's blog","logo":{"@type":"ImageObject","url":"https://xyz.desirer233.fun/images/icon2.png"}},"description":"这节课主要介绍了线性一致的概念与Zookeeper论文。 线性一致描述的是系统的行为，正确的行为是客户端发送了一个写请求并且收到服务端答复后，这个写请求能被之后的读请求看到。每个读请求看到的都是最新的写请求所作的更改。 Zookeeper论文是我接触到的最抽象的一篇论文。首先它的功能就很抽象：分布式协调内核。它提供的两个保证：线性写和FIFO客户端请求也费时间理解。最后则是它的API调用以及具体实"}</script><link rel="canonical" href="https://xyz.desirer233.fun/2023/11/27/MIT6.824/%E7%AC%94%E8%AE%B06Zookeeper/"><link rel="icon" href="/images/icon2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/bangumis">追番</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-27T03:04:00.000Z" title="2023/11/27 11:04:00">2023-11-27</time>发表</span><span class="level-item"><time dateTime="2024-06-09T13:00:22.510Z" title="2024/6/9 21:00:22">2024-06-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MIT6-824/">MIT6.824</a></span><span class="level-item">26 分钟读完 (大约3950个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MIT6824笔记六 线性一致与Zookeeper</h1><div class="content"><p>这节课主要介绍了线性一致的概念与Zookeeper论文。</p>
<p>线性一致描述的是系统的行为，正确的行为是客户端发送了一个写请求并且收到服务端答复后，这个写请求能被之后的读请求看到。每个读请求看到的都是最新的写请求所作的更改。</p>
<p>Zookeeper论文是我接触到的最抽象的一篇论文。首先它的功能就很抽象：分布式协调内核。它提供的两个保证：线性写和FIFO客户端请求也费时间理解。最后则是它的API调用以及具体实现。</p>
<p>读这篇论文的原因我想一是Zookeeper的广泛使用，证明了其实用性；二是其“线性一致”的设计，契合课程。收获就是其API的设计、Watch模式。</p>
<span id="more"></span>

<p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/363396366">【MIT 6.824】学习笔记 6: ZooKeeper - 知乎</a></p>
<h1 id="线性一致"><a href="#线性一致" class="headerlink" title="线性一致"></a>线性一致</h1><p>（1）例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example history 1:</span><br><span class="line">  |-Wx1-| |-Wx2-|</span><br><span class="line">    |---Rx2---|</span><br><span class="line">      |-Rx1-|</span><br><span class="line">is this history linearizable?</span><br></pre></td></tr></table></figure>

<p>满足以下两个要求：</p>
<ul>
<li>线性后的序列要与实际请求时间相匹配（一个请求的结束时间在另一个请求的开启时间之前，那么线性序列也必须遵守）</li>
<li>每个读请求看到都是序列中前一个写请求的值</li>
</ul>
<p>（2）线性一致</p>
<p><strong>线性一致更多描述的是关于系统行为的定义，我们只能通过一系列请求以及返回值来推测一个系统是否是线性一致的。</strong></p>
<p>在一个线性一致的系统中，读请求不允许返回旧的数据。也就是说，如果我发起了一个写请求，然后再读，如果读到的不是上次写的值，那这个系统就不是线性一致的。</p>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><blockquote>
<p>参考了个人笔记：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/363396366">https://zhuanlan.zhihu.com/p/363396366</a></p>
</blockquote>
<h2 id="介绍Zookeeper"><a href="#介绍Zookeeper" class="headerlink" title="介绍Zookeeper"></a>介绍Zookeeper</h2><p>Zookeeper是一个<strong>通用的分布式协调服务（General-Purpose Coordination Service）</strong>，通过提供协调内核&#x2F;客户端API的形式，让开发者自己实现诸多原语&#x2F;功能，<strong>包括统一命名、配置管理、成员管理、分布式锁、双重屏障等。</strong></p>
<p>Zookeeper<strong>基于Zab（类似Raft的基于领导者的原子广播协议）</strong>实现了多副本容错机制，但不同于Raft，<strong>Zookper的所有副本都能接受读请求</strong>。这得益于Zookeeper的两个设计：线性写和FIFO客户端请求。</p>
<p>Zookeeper为客户端提供了一组数据节点（称之为Znode），Znode根据分层名称空间进行组织，记法上类似于Unix的文件系统。<strong>客户端通过Zookeeper提供的API能对数据节点进行创建、删除、读取、写入、获取目录下所有文件等操作。</strong>Zookeeper还实现了一种Watch机制，通过此机制，客户端能够监听某个Znode的变化（更新、删除），Zookeeper会在Znode发生变化时向客户端发送一条通知消息。</p>
<h2 id="Zookeeper-API"><a href="#Zookeeper-API" class="headerlink" title="Zookeeper API"></a>Zookeeper API</h2><p><img src="http://markdown.desirer233.fun/202312131353054.png"></p>
<p>Zookeeper的API某种程度上来说像是一个文件系统。它有一个层级化的目录结构，有一个根目录（root），之后每个应用程序有自己的子目录。<strong>文件和目录都被称为znodes。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`CREATE(PATH，DATA，FLAG)`。入参分别是文件的全路径名PATH，数据DATA，和表明znode类型的FLAG。这里有意思的是，CREATE的语义是排他的。</span><br><span class="line"></span><br><span class="line">`DELETE(PATH，VERSION)`。入参分别是文件的全路径名PATH，和版本号VERSION。有一件事情我之前没有提到，每一个znode都有一个表示当前版本号的version，当znode有更新时，version也会随之增加</span><br><span class="line"></span><br><span class="line">`EXIST(PATH，WATCH)`。入参分别是文件的全路径名PATH，和一个有趣的额外参数WATCH。通过指定watch，你可以监听对应文件的变化。</span><br><span class="line"></span><br><span class="line">`GETDATA(PATH，WATCH)`。入参分别是文件的全路径名PATH，和WATCH标志位。这里的watch监听的是文件的内容的变化。</span><br><span class="line"></span><br><span class="line">`SETDATA(PATH，DATA，VERSION)`。入参分别是文件的全路径名PATH，数据DATA，和版本号VERSION。如果你传入了version，那么Zookeeper当且仅当文件的版本号与传入的version一致时，才会更新文件。</span><br><span class="line"></span><br><span class="line">`LIST(PATH)`。入参是目录的路径名，返回的是路径下的所有文件。</span><br></pre></td></tr></table></figure>

<p>Znode有两种基本类型：Regular和Ephemeral。创建的api还包括一个sequential flag。Znode还关联了时间戳、版本信息。</p>
<p><strong>更新方法都带有一个版本号参数，只有版本号与Znode的版本号一致时，更新操作才能成功。</strong></p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>如何利用Zookeeper实现动态配置管理？非常简单。</p>
<p>配置管理器将配置写在一个Znode中，其他进程读这个Znode，同时设置Watch标志位。如果Znode中的配置改变了，那么其他进程将会收到通知，并且会再次读取最新配置。</p>
<h3 id="集合点"><a href="#集合点" class="headerlink" title="集合点"></a>集合点</h3><p>Rendezvous我理解为进程同步。客户端创建Znode，然后将Zode的full path作为参数传递给master process和worker process。如果master process先创建完成，那么它就将它的信息（addresses and ports）写入到Znode中；如果是worker process先创建完成，它照样读取Znode并设置Watch标志位，后续mater改变Znode后，worker就能读取信息。</p>
<h3 id="组成员管理"><a href="#组成员管理" class="headerlink" title="组成员管理"></a>组成员管理</h3><p>利用一个Znode 表示组。当组成员创建时，只需创建一个对应的Znode的Child Znode。如果需要唯一的对应，可设置Sequentail标志位。如果需要获取一个Group的信息，只需要简单调用list api查看Znode的所有Child。如果一个进程要监视组信息的变化，为每一个组成员设置Watch标志位即可。</p>
<p>ephemeral node有一个好处是能代表会话的状态，当进程失败或结束时，ephemeral node会自动移除。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE TRUE:</span><br><span class="line">    IF CREATE(&quot;f&quot;, data, ephemeral=TRUE): RETURN</span><br><span class="line">    IF EXIST(&quot;f&quot;, watch=TRUE):</span><br><span class="line">        WAIT</span><br></pre></td></tr></table></figure>

<p>总的来说，先是通过CREATE创建锁文件，或许可以直接成功。如果失败了，我们需要等待持有锁的客户端释放锁。通过Zookeeper的watch机制，我们会在锁文件删除的时候得到一个watch通知。收到通知之后，我们回到最开始，尝试重新创建锁文件，如果运气足够好，那么这次是能创建成功的。</p>
<h3 id="Herd-Effect"><a href="#Herd-Effect" class="headerlink" title="Herd Effect"></a>Herd Effect</h3><p>如果有1000个客户端同时要获得锁文件，为1000个客户端分发锁所需要的时间也是N方。因为每一次锁文件的释放，所有剩下的客户端都会收到WATCH的通知，并且回到循环的开始，再次尝试创建锁文件。</p>
<p><strong>为了获得锁，要通知一大群的线程，也就是惊群，最会只有一个线程能获得锁。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE(&quot;f&quot;, data, sequential=TRUE, ephemeral=TRUE)</span><br><span class="line">WHILE TRUE:</span><br><span class="line">    LIST(&quot;f*&quot;)</span><br><span class="line">    IF NO LOWER #FILE: RETURN</span><br><span class="line">    IF EXIST(NEXT LOWER #FILE, watch=TRUE):</span><br><span class="line">        WAIT</span><br></pre></td></tr></table></figure>

<p>代码第4行，如果现存的Sequential文件的序列号都不小于我们在代码第1行得到的序列号，那么表明我们在并发竞争中赢了，我们获得了锁。所以当我们的Sequential文件对应的序列号在所有序列号中最小时，我们获得了锁，直接RETURN。序列号代表了不同客户端创建Sequential文件的顺序。在这种锁方案中，会使用这个顺序来向客户端分发锁。当存在更低序列号的Sequential文件时，我们要做的是等待拥有更低序列号的客户端释放锁。在这个方案中，释放锁的方式是删除文件。所以接下来，我们需要做的是等待序列号更低的锁文件删除，之后我们才能获得锁。</p>
<p>所以，在代码的第5行，我们调用EXIST，并设置WATCH，等待比自己序列号更小的下一个锁文件删除。如果等到了，我们回到循环的最开始。但是这次，我们不会再创建锁文件，代码从LIST开始执行。这是获得锁的过程，释放就是删除创建的锁文件。</p>
<blockquote>
<p>学生提问：为什么这种锁不会受羊群效应（Herd Effect）的影响？</p>
<p>Robert教授：假设我们有1000个客户端在等待获取锁，每个客户端都会在代码的第6行等待锁释放。但是每个客户端等待的锁文件都不一样，比如序列号为500的锁只会被序列号为501的客户端等待，而序列号500的客户端只会等待序列号499的锁文件。</p>
<p>每个客户端只会等待一个锁文件，<strong>当一个锁文件被释放，只有下一个序列号对应的客户端才会收到通知，</strong>也只有这一个客户端会回到循环的开始，也就是代码的第3行，之后这个客户端会获得锁。所以，不管有多少个客户端在等待锁，每一次锁释放再被其他客户端获取的代价是一个常数。而在非扩展锁中，锁释放时，每个等待的客户端都会被通知到，之后，每个等待的客户端都会发送CREATE请求给Zookeeper，所以每一次锁释放再被其他客户端获取的代价与客户端数量成正比。</p>
</blockquote>
<h3 id="双重屏障"><a href="#双重屏障" class="headerlink" title="双重屏障"></a>双重屏障</h3><p>&#x2F;&#x2F; todo</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>第一个很简单的例子是计数器，假设我们在Zookeeper中有一个文件，我们想要在那个文件存储一个统计数字，例如，统计客户端的请求次数，当收到了一个来自客户端的请求时，我们需要增加存储的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE TRUE:</span><br><span class="line">    X, V = GETDATA(&quot;F&quot;)</span><br><span class="line">    IF SETDATA(&quot;f&quot;, X + 1, V):</span><br><span class="line">        BREAK</span><br></pre></td></tr></table></figure>

<p>这个例子，其实就是大家常说的mini-transaction。这里之所以是事务的，是因为一旦我们操作成功了，我们对计数器达成了_<strong>读-更改-写</strong>_的原子操作。</p>
<p>之所以称之为mini-transaction，是因为这里并不是一个完整的数据库事务（transaction）。一个真正的数据库可以使用完整的通用的事务，你可以指定事务的开始，然后执行任意的数据读写，之后结束事务。一个真实的事务可能会非常复杂，而Zookeeper支持这种非常简单的事务，<strong>使得我们可以对于一份数据实现原子操作。</strong>这对于计数器或者其他的一些简单功能足够了。所以，这里的事务并不通用，但是的确也提供了原子性，所以它被称为mini-transaction。</p>
<h2 id="Zookeeper的保证"><a href="#Zookeeper的保证" class="headerlink" title="Zookeeper的保证"></a>Zookeeper的保证</h2><p>Zookeeper基于Raft框架，是容错的，在发生网络分区的时候，也能有正确的行为。Zookeeper有一些性能增强，使得读请求可以在任何副本被处理，因此，可能会返回旧数据。</p>
<p><strong>为什么Zookeeper在允许多副本读的情况下还能保证正确的行为？</strong></p>
<p>这得益于ZooKeeper 两个基本的一致性保证：线性写和先进先出(FIFO)的客户端请求。</p>
<h3 id="写请求是线性一致的"><a href="#写请求是线性一致的" class="headerlink" title="写请求是线性一致的"></a>写请求是线性一致的</h3><blockquote>
<p>All requests that update the state of ZooKeeper are serializable and respect precedence.</p>
</blockquote>
<p>Leader 保证写操作的顺序，并且该顺序在所有 Follower 上保持一致。</p>
<p>客户端可以并发的发送写请求，然后Zookeeper表现的就像以某种顺序，一次只执行一个写请求，并且也符合写请求的实际时间。所以如果一个写请求在另一个写请求开始前就结束了，那么Zookeeper实际上也会先执行第一个写请求，再执行第二个写请求。</p>
<p>所有更改Zookeeper状态的请求都是线性的，那么这就保证了主从状态一致性。</p>
<h3 id="先进先出的客户端请求"><a href="#先进先出的客户端请求" class="headerlink" title="先进先出的客户端请求"></a><strong>先进先出的客户端请求</strong></h3><blockquote>
<p>All requests from a given client are executed in the order that they were sent by the client.</p>
</blockquote>
<p>每个客户端可以为其操指定一个顺序，ZooKeeper 会按照客户端指定的顺序来执行。<strong>即zookeeper为每个单独的客户端提供了线性一致性。</strong></p>
<p>这里的线性一致性只对于单个客户端的请求。<strong>比如说，客户端先发了一个写请求，然后再发读请求到落后的副本，那么这个读请求得看到它自己之前的写更新。</strong></p>
<blockquote>
<p>所以，如果我发送一个写请求给Leader，在Leader commit这个请求之前需要消耗一些时间，所以我现在给Leader发了一个写请求，而Leader还没有处理完它，或者commit它。之后，我发送了一个读请求给某个副本。这个读请求需要暂缓一下，以确保FIFO客户端请求序列。读请求需要暂缓，直到这个副本发现之前的写请求已经执行了。这是FIFO客户端请求序列的必然结果，（对于某个特定的客户端）读写请求是线性一致的。</p>
</blockquote>
<p>ZooKeeper 通过 <code>zxid</code> 来实现，<code>zxid</code> 是最后一个事务的标记，当客户端发出一个请求到一个相同或者不同的副本时，会在请求带上 <code>zxid</code> 标记，副本通过检查客户端的 <code>zxid</code> 和自己的 <code>zxid</code>，保证读到的是更新的 <code>zxid</code> 的数据(没有具体说怎么处理，是阻塞等待还是拒绝请求)</p>
<p>更进一步，如果同一个客户端发送一个写请求<code>&lt;X, 17&gt;</code>，然后立即去某个副本服务器读 X，这里会暂缓一下读请求，直到这个副本发现写请求的 <code>zxid</code> 已经执行了，即<strong>客户端将会读到</strong> <strong><code>&lt;X, 17&gt;</code>，不会读到过期的数据。</strong></p>
<h3 id="同步操作-sync"><a href="#同步操作-sync" class="headerlink" title="同步操作 sync"></a>同步操作 sync</h3><p><strong>尽管有了Zookeeper的两个保证，但这还不是线性一致性。Zookeeper提供了另外一种弥补线性一致的方法：sync。</strong></p>
<blockquote>
<p>To handle this scenario more efficiently ZooKeeper provides the sync request: when followed by a read, constitutes a slow read. sync causes a server to apply all pending write requests before processing the read without the overhead of a full write. This primitive is similar in idea to the flush primitive of ISIS。</p>
</blockquote>
<p>可以简单认为sync操作等于原子的写+读。这样客户端的读操作一定能看到最新的写入操作。因为FIFO的客户端请求使得它看到了自己的写请求，而写请求又是线性的，于是之前的写请求一定也被看见。</p>
<h2 id="Zookeeper的实现"><a href="#Zookeeper的实现" class="headerlink" title="Zookeeper的实现"></a>Zookeeper的实现</h2><p>&#x2F;&#x2F;todo</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>MIT6824笔记六 线性一致与Zookeeper</p><p><a href="https://xyz.desirer233.fun/2023/11/27/MIT6.824/笔记6Zookeeper/">https://xyz.desirer233.fun/2023/11/27/MIT6.824/笔记6Zookeeper/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Desirer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-11-27</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-06-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/12/01/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/%E7%BB%88%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">终端基础知识</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/11/25/MIT6.824/%E7%AC%94%E8%AE%B04VMwareFT/"><span class="level-item">MIT6824笔记四 容错与FTVM</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#线性一致"><span class="level-left"><span class="level-item">1</span><span class="level-item">线性一致</span></span></a></li><li><a class="level is-mobile" href="#ZooKeeper"><span class="level-left"><span class="level-item">2</span><span class="level-item">ZooKeeper</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#介绍Zookeeper"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">介绍Zookeeper</span></span></a></li><li><a class="level is-mobile" href="#Zookeeper-API"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Zookeeper API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#配置管理"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">配置管理</span></span></a></li><li><a class="level is-mobile" href="#集合点"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">集合点</span></span></a></li><li><a class="level is-mobile" href="#组成员管理"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">组成员管理</span></span></a></li><li><a class="level is-mobile" href="#分布式锁"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">分布式锁</span></span></a></li><li><a class="level is-mobile" href="#Herd-Effect"><span class="level-left"><span class="level-item">2.2.5</span><span class="level-item">Herd Effect</span></span></a></li><li><a class="level is-mobile" href="#双重屏障"><span class="level-left"><span class="level-item">2.2.6</span><span class="level-item">双重屏障</span></span></a></li><li><a class="level is-mobile" href="#计数器"><span class="level-left"><span class="level-item">2.2.7</span><span class="level-item">计数器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Zookeeper的保证"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Zookeeper的保证</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#写请求是线性一致的"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">写请求是线性一致的</span></span></a></li><li><a class="level is-mobile" href="#先进先出的客户端请求"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">先进先出的客户端请求</span></span></a></li><li><a class="level is-mobile" href="#同步操作-sync"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">同步操作 sync</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Zookeeper的实现"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Zookeeper的实现</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MIT6-824/"><span class="level-start"><span class="level-item">MIT6.824</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/"><span class="level-start"><span class="level-item">MIT6.S081</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/MIT6-S081/lab/"><span class="level-start"><span class="level-item">lab</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/MIT6-S081/xv6book/"><span class="level-start"><span class="level-item">xv6book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/OpenGauss/"><span class="level-start"><span class="level-item">OpenGauss</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/PostgreSQL/"><span class="level-start"><span class="level-item">PostgreSQL</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/cmu15445/"><span class="level-start"><span class="level-item">cmu15445</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">工具学习</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/GDB/"><span class="level-start"><span class="level-item">GDB</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/IDE/"><span class="level-start"><span class="level-item">IDE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="level-start"><span class="level-item">命令行</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%A2%98%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">单题题解</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="level-start"><span class="level-item">数组与字符串</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">生活哲学</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">网站搭建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/icon2.png" alt="Desirer&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Desirer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Desirer</a><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023035608</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>